{"meta":{"title":"Kuai-hua's Blog","subtitle":"","description":"从现在开始","author":"Kuai-hua","url":"https://kuai-hua.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-11-07T00:57:21.000Z","updated":"2022-11-07T00:59:02.140Z","comments":true,"path":"categories/index.html","permalink":"https://kuai-hua.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-07T00:48:40.000Z","updated":"2022-11-07T00:59:34.572Z","comments":true,"path":"tags/index.html","permalink":"https://kuai-hua.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"多线程","slug":"多线程","date":"2022-11-17T07:35:00.000Z","updated":"2022-12-08T11:52:45.965Z","comments":true,"path":"2022/11/17/多线程/","link":"","permalink":"https://kuai-hua.github.io/2022/11/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"进程","text":"进程 核心概念 创建方式 run()和start() 三种方式第一种：继承Thread 第二种：实现runable实现龟兔赛跑12345678910111213141516171819202122232425262728293031323334public class KuangRace implements Runnable&#123; private static String winner; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; boolean flag = gameOver(i); if (flag)&#123; break; // 游戏结束 &#125; System.out.println(Thread.currentThread().getName() + &quot;跑了第&quot;+ i + &quot;步!&quot;); &#125; &#125; private boolean gameOver(int steps)&#123; if (winner != null)&#123; return true; // 有胜利者游戏就结束了 &#125; if(steps &gt;= 100)&#123; // 步数到了100就说明胜利者产生了 winner = Thread.currentThread().getName(); System.out.println(&quot;======================Winner is &quot;+ winner); return true; &#125; return false; &#125; public static void main(String[] args) &#123; KuangRace kuangRace = new KuangRace(); new Thread(kuangRace,&quot;乌龟&quot;).start(); new Thread(kuangRace,&quot;兔子&quot;).start(); &#125;&#125; 第三种: Callable Lambda(演化过程) 从1~6是逐步发展的过程,是逐渐简化的过程,需要习惯,所有事情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.kuaihua.lambda;public class TestLambda &#123; // 3.静态内部类 static class Like2 implements ILike&#123; public void lambda() &#123; System.out.println(&quot;====Lambda2====&quot;); &#125; &#125; public static void main(String[] args) &#123; ILike like = new Like(); like.lambda(); like = new Like2(); like.lambda(); // 4.局部内部类 class Like3 implements ILike&#123; @Override public void lambda() &#123; System.out.println(&quot;====Lambda3====&quot;); &#125; &#125; like = new Like3(); like.lambda(); like = new ILike() &#123; @Override public void lambda() &#123; System.out.println(&quot;====Lambda4====&quot;); &#125; &#125;; like.lambda(); // 6.用lambda来简化 like = ()-&gt;&#123; System.out.println(&quot;====Lambda5====&quot;); &#125;; like.lambda(); &#125;&#125;// 1.定义一个函数式接口interface ILike&#123; void lambda();&#125;// 2. 实现一个接口class Like implements ILike&#123; @Override public void lambda() &#123; System.out.println(&quot;====Lambda====&quot;); &#125;&#125; 进程五种运行状态 线程的常用方法 停止线程 线程休眠(sleep ) 线程礼让(yield) &#x3D;&#x3D;不一定成功&#x3D;&#x3D; 线程插队(join) 线程的五个状态跟查看方法 报错是因为死亡的线程是不能再次启动的 不然就会报错 线程优先级 守护进程(daemon) 123456789101112131415161718192021222324252627282930313233public class DaemonTest &#123; public static void main(String[] args) &#123; God god = new God(); You you = new You(); Thread thread = new Thread(god); // // 开启守护进程 thread.setDaemon(true); // false是默认值,也代表正常用户,如果为true就表示这是一个守护进程,用户进程死了,守护也就死了,虚拟机不用等待守护进程结束 thread.start(); // 进程开始 new Thread(you).start(); &#125;&#125;class God implements Runnable&#123; @Override public void run() &#123; while (true)&#123; System.out.println(&quot;============God==========&quot;); &#125; &#125;&#125;class You implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 36500; i++) &#123; System.out.println(&quot;开心每一天===============&quot;); &#125; System.out.println(&quot;GoodBye, World!&quot;); &#125;&#125; 并发 synchronized(辛口耐s)同一个对象被多个线程同时操作 队列+锁 线程同步 同步弊端 锁: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.kuaihua.thread.Lock;public class DeadLock &#123; public static void main(String[] args) &#123; MakeUp g1 = new MakeUp(0, &quot;灰姑凉&quot;); MakeUp g2 = new MakeUp(2, &quot;白雪&quot;); g1.start(); g2.start(); &#125;&#125;class Lipstick&#123;&#125;class Mirror&#123;&#125;class MakeUp extends Thread &#123; int choice; String girlName; static Lipstick lipstick = new Lipstick(); // 静态方法让这个变量只有一个,也就是只有一个口红 static Mirror mirror = new Mirror(); public MakeUp(int choice,String girlName)&#123; this.choice = choice; this.girlName = girlName; &#125; @Override public void run() &#123; try &#123; makeup(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; private void makeup() throws InterruptedException &#123; if (choice==0)&#123; synchronized (lipstick)&#123; // 获得口红的锁 System.out.println(this.girlName+&quot;获取了口红的锁&quot;); Thread.sleep(1000); // synchronized (mirror)&#123; // System.out.println(this.girlName + &quot;获得了镜子的锁&quot;); // &#125; &#125; synchronized (mirror)&#123; System.out.println(this.girlName + &quot;获得了镜子的锁&quot;); &#125; &#125;else &#123; synchronized (mirror)&#123; // 获得口红的锁 System.out.println(this.girlName+&quot;获取了镜子的锁&quot;); Thread.sleep(2000); // synchronized (lipstick)&#123; // System.out.println(this.girlName + &quot;获得了口红的锁&quot;); // &#125; &#125; synchronized (lipstick)&#123; System.out.println(this.girlName + &quot;获得了口红的锁&quot;); &#125; &#125; &#125;&#125; 死锁避免方法 可重复锁 Lock与synchronized(辛口耐s)的区别 reentrantlock(吕an去lock)可重复锁线程池 使用 总结:","categories":[],"tags":[]},{"title":"注解和反射","slug":"注解和反射","date":"2022-11-14T03:58:19.000Z","updated":"2022-11-14T03:58:20.149Z","comments":true,"path":"2022/11/14/注解和反射/","link":"","permalink":"https://kuai-hua.github.io/2022/11/14/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"idea报错异常的原因跟处理方式(java跟springboot版本也记录)","slug":"idea报错异常的原因跟处理方式","date":"2022-11-12T04:46:37.000Z","updated":"2022-11-14T01:34:40.584Z","comments":true,"path":"2022/11/12/idea报错异常的原因跟处理方式/","link":"","permalink":"https://kuai-hua.github.io/2022/11/12/idea%E6%8A%A5%E9%94%99%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E8%B7%9F%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","excerpt":"1. 数组越界(ArrayIndexOutOfBoundsException:数字)123456789101112public class ArrayDemo01 &#123; public static void main(String[] args) &#123; int[] nums; nums = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; nums[i] = i+1; System.out.println(nums[i]); &#125; // 数组越界,下标最大只有nums[9] System.out.println(nums[10]); &#125;&#125;","text":"1. 数组越界(ArrayIndexOutOfBoundsException:数字)123456789101112public class ArrayDemo01 &#123; public static void main(String[] args) &#123; int[] nums; nums = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; nums[i] = i+1; System.out.println(nums[i]); &#125; // 数组越界,下标最大只有nums[9] System.out.println(nums[10]); &#125;&#125; 表示我们数组的第几个下标越界了 2.类型转换异常 ClassCastException","categories":[{"name":"报错","slug":"报错","permalink":"https://kuai-hua.github.io/categories/%E6%8A%A5%E9%94%99/"}],"tags":[]},{"title":"java基础知识回顾","slug":"java基础复习","date":"2022-11-11T01:28:23.000Z","updated":"2022-11-19T12:50:34.989Z","comments":true,"path":"2022/11/11/java基础复习/","link":"","permalink":"https://kuai-hua.github.io/2022/11/11/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","excerpt":"&#x3D;&#x3D;查漏补缺,没有写细节,细节大都都懂&#x3D;&#x3D; 数据类型java 数据类型优先级12由低到高:byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double","text":"&#x3D;&#x3D;查漏补缺,没有写细节,细节大都都懂&#x3D;&#x3D; 数据类型java 数据类型优先级12由低到高:byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 123456789101112131个字节8位 计算机的基本单位：bit . 一个bit代表一个0或1byte：1byte = 8bit 1个字节是8个bitbyte 8bit 默认为0，取值-128–127short 16bit 默认为0，取值-32768–32767int 32bit 默认为0，取值-21亿–21亿long 64bit 默认为0，取值-922亿亿–922亿亿double 64bit 默认为0.0d，一般数为整数是加上d用于区分float 32bit 默认为0.0ffchar 16bit 默认’\\u0000’boolean 1bit 默认false 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入 知识点:最好不要使用浮点数进行比较,原因:因为浮点数是有限的,有舍入误差 常量(staic ,final) Scanner(前期交互)Scanner对象 eg: next()与nextLine() 流程控制12341. 顺序结构(所有的程序都有)2. 选择结构(if,switch ... case..break)3. 循环结构(while,for,do...while(代码至少被执行了一次)) - while(true) 伪代码,死循环,尽量避免 ifswitch …case(常与break连用)不予break连用,会出现&#x3D;&#x3D;case穿透&#x3D;&#x3D;问题 在jdk7以后才支持字符串的比较 for最有效,灵活的循环结构 1idea快捷键: 100.for 12345678910111213141516171819package com.kuaihua.struct;public class ForDemo01 &#123; public static void main(String[] args) &#123; int []numbers = &#123;20,30,40,50&#125;; // 定义一个数组 // 第一种方式 for (int i = 0; i &lt; numbers.length; i++) &#123; System.out.println(numbers[i]); &#125; System.out.println(&quot;=========================&quot;); // 第二种方式(简化) 快捷方式 :numbers.for for (int i : numbers) &#123; System.out.println(i); &#125; &#125;&#125; break与continue的区别1break只是结束本次循环,不会结束上一级的循环 123456789101112131415161718public class ForDemo02 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; while (j==30) &#123; System.out.println(30); break; &#125; &#125; System.out.println(i); if (i==20)&#123; break; &#125; &#125; &#125;&#125; 12345678910111213141516public class ForDemo03 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; if (j&gt;10) continue; System.out.println(&quot;j=====&gt;&quot; + j); &#125; System.out.println(&quot;i=====&gt;&quot; + i); &#125; &#125;&#125; 编译与反编译文件编译文件:java(我们可以看懂)–&gt;class(乱码) 反编译:class—&gt;java 每一个对象都有一个通过算法获取的hashcode,通过对比hashcode的不同就可以知道两个值是不是一样,这样才可以进行string的比较 方法什么是方法: 1return 0; // 还有终止方法的作用,如果需要终止某个任务的话 重载什么是重载:方法重载的要求是两同一不同：&#x3D;&#x3D;同一个类&#x3D;&#x3D;中&#x3D;&#x3D;同样的方法名&#x3D;&#x3D;，参数列表不同。至于方法的其他部分，如方法返回值类型、修饰符等，与方法重载没有任何关系。 方法重载的要求是两同一不同：同一个类中方法名相同，参数列表不同。至于方法的其他部分，如方法返回值类型、修饰符等，与方法重载没有任何关系。 重写要求: 必须得有继承关系,子类重写父类方法 参数列表必须相同 范围可以扩大,但是不能缩小 异常的范围可以缩小,不能扩大(可以更加具体,但是不能更加省略,因为父类就是exception) 1重写有参构造后无参构造就会失效,所以在加上有参构造的时候都会先加上无参构造,不然会报错,很多方法调用不了 可变参数 传递123传递方式: - 值传递 - 引用传递 &#x3D;&#x3D;java都是值传递思想&#x3D;&#x3D; 递归 数组1int[] array = new int[60]; 数组特点 12345- 长度确定不可以修改- 元素必须是相同类型的,创建很好记,int为整型,那么[]为数组(个人理解)- 数组元素可以是任何类型,可以是基本类型,也可以是引用类型,eg:new Man()- 数组变量属于引用类型,数组可以看成对象,数组中每个元素相当于对象的成员变量- 数组本身是对象,对象放在#堆中# 数组一旦创建就不可以修改,页有他们的初始值 1234567891011121314151617181920212223242526public class ArrayDemo02 &#123; public static void main(String[] args) &#123; int[] nums= new int[10]; long[] longs = new long[10]; String[] strings= new String[10]; double[] doubles= new double[10]; char[] chars= new char[10]; boolean[] booleans = new boolean[10]; System.out.println(&quot;nums 初始值&quot; + nums[0]); System.out.println(&quot;longs 初始值&quot; + longs[0]); System.out.println(&quot;strings 初始值&quot; +strings[0]); System.out.println(&quot;doubles 初始值&quot; +doubles[0]); System.out.println(&quot;chars 初始值&quot; +chars[0]); System.out.println(&quot;booleans 初始值&quot; +booleans[0]); &#125;&#125;=========================================================nums 初始值0longs 初始值0strings 初始值nulldoubles 初始值0.0chars 初始值 booleans 初始值false 二维数组:int 类型的一维数组,元素都是整数, 稀疏数组记录有数组(记作A数组)中不为默认值的数组的位置,保存在另一个数组(记作 B数组)中,另一个数组的第一行分别记录第一个数组A的二维(行列数),第三个记录A数组中不为0的元素个数 然后在B数组中记录A数组中元素值不为0的元素在数组A中的位置,并记录它的值 Array类(Jdk自带的)1234常用的几个自带的方法: - Array.toString() - Array.sort() # 排序,由小到大排 - Array.fill() # 填充 面向对象编程(OOP)&#x3D;&#x3D;本质:以类的方式组织代码,以对象的组织(封装)数据&#x3D;&#x3D; 三大特性 封装 继承 1Super() 调用父类中的方法 12在java中,所有的类都直接或者间接继承&quot;Object类&quot;在java中只有单继承,但是可以间接继承多个 多态 instanceof 判断两个类之间是否存在父子关系 方法 静态方法(有static) ​ 可以直接调用,不用new一个对象,直接就可以点出来 非静态方法 ​ 需要new 一个对象,然后才可以点出来,如图所示 1234567891011121314151617181920212223242526272829public class Demo01 &#123; public static void main(String[] args) &#123; Student.say(); Teacher teacher = new Teacher(); teacher.say(); &#125;&#125;==============================================================public class Teacher &#123; public void say()&#123; System.out.println(&quot;这不是一个静态方法,老师讲课===&quot;); &#125;&#125;=============================================================== public class Student &#123; public static void say()&#123; // 有static,是个静态方法 System.out.println(&quot;这是一个静态方法,学生说话了&quot;); &#125;&#125; 有static的静态方法,在类一开始时候就创建了,所以有 Super与This Static(静态)静态的,类加载的时候就启动了,也只会启动一次 静态方法可以调用静态方法,如果变量用static修饰就成了类变量,可以直接类名点的方式调用, 可以这样 final(无子类,不能被继承[断子绝孙])抽象类(abstract)只能通过extends实现单继承特点: 抽象类里面&#x3D;&#x3D;可以有普通方法&#x3D;&#x3D; 抽象方法&#x3D;&#x3D;必须在抽象类里面&#x3D;&#x3D; 抽象类&#x3D;&#x3D;不能去new,只 能靠子类去实现它 约束!&#x3D;&#x3D; 123456789101112131415// 抽象类public abstract class Demo05 &#123; // 只是个约束,有人帮我们实现了 // abstract 抽象类,只有方法名字,没有方法的实现 public abstract void say(); public void jump()&#123; System.out.println(&quot;ikun is jumping&quot;); &#125; // 抽象类里面可以有普通方法 // 抽象方法必须在抽象类里面 // 抽象类不能去new,只能靠子类去实现它 约束!&#125; 接口(interface):可以实现(&#x3D;&#x3D;伪多继承&#x3D;&#x3D;)&#x3D;&#x3D;一般都是要接口去new 实现类&#x3D;&#x3D; 例子: 123456789101112// 关键字 interfance ,接口都需要有实现类,接口只能写方法,不能写方法体.这还是与abstract(抽象类)最根本的区别public interface UserService &#123; int G = 99; // 一般简写 public static final int A = 100; // 全写 void say(); // public abstract void say(); public abstract void run();&#125; 12345public interface TimeService &#123; void jump();&#125; 1234567891011121314151617public class UserServiceImpl implements UserService,TimeService&#123; @Override public void jump() &#123; &#125; @Override public void say() &#123; &#125; @Override public void run() &#123; &#125;&#125; 堆和栈 1 异常类别 捕获异常: 快捷键:Ctrl+alt+T","categories":[],"tags":[]},{"title":"mybatis","slug":"mybatis","date":"2022-11-10T00:59:46.000Z","updated":"2022-11-10T11:42:20.234Z","comments":true,"path":"2022/11/10/mybatis/","link":"","permalink":"https://kuai-hua.github.io/2022/11/10/mybatis/","excerpt":"常用的仓库和配置：Mybatis官网","text":"常用的仓库和配置：Mybatis官网 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;dependencies&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- pom.xml 注意：在添加了此段代码后需要刷新maven，不然可能不生效建议父子工程都添加--&gt;&lt;!-- 在build中配置resources，来防止我们资源导出失败的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;!--按需求添加--&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;!--按需求添加--&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.21&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; Mybatis1.1什么是Mybatis MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和 获取结果集的工作 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 1.2maven仓库1234567&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 1.3持久化数据持久化 持久层：数据从持久状态与瞬时状态之间转化 内存：断电即失 为什么：内存太贵 类似：冷藏 持久层Dao层，servlet层，service层 controller层 1.4为什么学mybatis 简单易学 灵活 sql与代码分离，提高维护性 提供映射标签，支持数据对象与orm字段映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，至此编写动态的sql 1、第一个mybatis1.1、万能的map实例(可以用于模糊查询) UserDao接口代码12// 用map来修改用户消息int updateUser(Map&lt;String,Object&gt; map); UserMapper.xml的sql语句 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt; update mybatis.user set name =#&#123;username&#125;,pwd=#&#123;password&#125; where id=#&#123;userid&#125;&lt;/update&gt; 测试代码 12345678910111213141516public void updateUserTest()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserDao mapper = sqlSession.getMapper(UserDao.class); Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put(&quot;userid&quot;,&quot;1&quot;); map.put(&quot;password&quot;,&quot;122211212&quot;); map.put(&quot;username&quot;,&quot;笑笑&quot;); mapper.updateUser(map); sqlSession.commit(); sqlSession.close();&#125; 1.2、文件组成 七大步骤，要熟练掌握，其中有很多是配置文件 1.pom.xml，依赖和防止资源导出问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;dependencies&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- pom.xml 注意：在添加了此段代码后需要刷新maven，不然可能不生效建议父子工程都添加--&gt; &lt;!-- 在build中配置resources，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;!--按需求添加--&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;!--按需求添加--&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2.mybatis-config.xml核心配置问价123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;!-- 这里前面的jdbc不能丢，第一次错误因为这个jdbc:mysql://localhost..... --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;888888&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 必不可少的过程，连接，很重要 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuaihua/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.MybatisUtils工具类，这个是不变的，用来使用mybatis最重要的一个类1234567891011121314151617181920212223242526272829303132package com.kuaihua.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; // 第一步：使用Mybatis第一步，获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 第二步：有了sqlSessionFactory对象，就得从sqlSessionFactory中获取sqlSession实例 // SqlSession中包含了面向数据库执行SQL命令执行所需要的所有方法 public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 4.User.java常见的实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.kuaihua.pojo;public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 5.UserDao层，以后这里的Dao后缀就用Mapper代替，比如UserMapper12345678910111213package com.kuaihua.dao;import com.kuaihua.pojo.User;import java.util.List;// 用UserMapper.xml文件代替了UserDaoImpl.java文件，这就是mybatis的最大不同// 这里以后用UserMapper代替，UserDao文件变成UserMapper文件,public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 6.UserMapper.xml，***Mapper后缀只是常用的方法，这是用来代替UserDaoImpl.java的xml文件123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuaihua.dao.UserDao&quot;&gt; &lt;!--这里的id是com.kuaihua.dao.UserDao类下的getUserList方法，resultType是返回值类型，必须写成实体类--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuaihua.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 7.UserDaoTest.java这是一个测试方法，用来验证一下是否可以正常运行12345678910111213141516public class UserDaoTest &#123; @Test public void Test()&#123; // 第一步获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for(User user : userList)&#123; System.out.println(user); &#125; sqlSession.close(); &#125;&#125; 2、CRUD namespace ***maper.xml文件中里面的内容必须绑定的是里面内容必须是接口名字 一、查询不需要提交事务1.增加接口方法123456public interface UserDao &#123; // 查询所有用户 List&lt;User&gt; getUserList(); // 根据id查询用户 User getUserById(int id); 2.增加对应的xml中的sql方法，id对应方法名123456789&lt;mapper namespace=&quot;com.kuaihua.dao.UserDao&quot;&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuaihua.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuaihua.pojo.User&quot;&gt; select * from mybatis.user where id = #&#123;id&#125;; &lt;/select&gt; 3.测试方法12345678910111213141516171819202122232425@Testpublic void getUserListTest()&#123; // 第一步获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for(User user : userList)&#123; System.out.println(user); &#125; sqlSession.close();&#125;@Testpublic void getUserByIdTest()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = userDao.getUserById(1); System.out.println(user); sqlSession.close();&#125; 二、增删改的测试文件中需要提交事务，sqlSession.commit()1.增加接口方法123456// 添加一个用户int addUser(User user);// 根据id删除一个用户int deleteUserById(int id);// 根据id修改用户t updateUserById(User user); 2.增加对应的xml中的sql方法，id对应方法名1234567891011&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuaihua.pojo.User&quot;&gt; insert into mybatis.user(id, name, pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&lt;/insert&gt;&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id=#&#123;id&#125;&lt;/delete&gt;&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.kuaihua.pojo.User&quot;&gt; update mybatis.user set name =#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;&lt;/update&gt; 3.测试方法1234567891011121314151617181920212223242526272829303132333435363738// 增删改都需要提交事务，很重要 @Test public void addUserTest()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); int user = userDao.addUser(new User(4, &quot;王五&quot;, &quot;2165124&quot;)); // 增删改都需要提交事务 sqlSession.commit(); sqlSession.close(); &#125; @Test public void deleteUserByIdTest()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); int i = userDao.deleteUserById(4); if (i&gt;0)&#123; System.out.println(&quot;删除了一个用户&quot;); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test public void updateUserByIdTest()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); int num = userDao.updateUserById(new User(1, &quot;哈哈&quot;, &quot;1234658888&quot;)); if (num&gt;0)&#123; System.out.println(&quot;修改了一个用户资料&quot;); &#125; sqlSession.commit(); sqlSession.close(); &#125; 三、模糊查询1.在java执行代码的时候，传递通配符查询% %1List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;) 2.在sql拼接中使用通配符1select * from user where name like &quot;%&quot; #&#123;value&#125; &quot;%&quot; 3、配置解析，核心配置文件（mybatis-config.xml） MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： &#x3D;&#x3D;这里的顺序安排好的,打乱会报错&#x3D;&#x3D; 1234567891011121314properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 1、environments（环境配置） **尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。** 123456789101112&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;888888&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC/Manged（两种）&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED(有三种)&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 2、属性（properties）1234driver = com.mysql.cj.jdbc.Driverurl = jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueusername = rootpassword = 888888 3、typeAliases（类型别名） 类型别名可为 Java 类型设置一个缩写名字 仅用于 XML 配置，意在降低冗余的全限定类名书写 3.1给实体类起别名（实体类比较少的时候）1234&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.kuaihua.pojo.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; 在User Mapper.xml中的resultType可以这样设置 123&lt;select id=&quot;getUserList&quot; resultType=&quot;user&quot;&gt; select * from mybatis.user &lt;/select&gt; 3.2给实体包起别名（实体类比较多的时候）默认的别名就是实体包下的文件名首字母小写，比如这里就是user&#x2F;User 123&lt;typeAliases&gt; &lt;package name=&quot;com.kuaihua.pojo&quot;/&gt; &lt;/typeAliases&gt; 3.3实体类注解1234@Alias(&quot;user&quot;)public class User &#123; ...&#125; 4、映射器（mappers）又四种，常用的只有三种，但是第一种最常用，url不使用12345&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt; 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 使用第二种跟第三种方法注意 接口与它的Mapper配置文件必须同名 接口与它的Mapper配置文件必须在同一个包下 4、解决属性名与字段名不一致问题12345public class User &#123; private int id; private String name; private String password;&#125; 测试出现的问题 比如在实体类中User的password字段在数据库对应为pwd,就需要一如结果集映射 12345&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- column表示数据库的字段名，property表示实体类属性 --&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt; &lt;/resultMap&gt; 1&lt;select id=&quot;getUserList&quot; resultType=&quot;user&quot;&gt; select * from mybatis.user&lt;/select&gt; 出现原因，数据库的字段名与属性名不一致 数据库 实体类 id id name name pwd password 解决办法 4.1.起别名1&lt;select id=&quot;getUserList&quot; resultType=&quot;user&quot;&gt; select id,name,pwd as password from mybatis.user&lt;/select&gt; 4.2.结果集映射(resultMap)后面加了一个resultMap=&quot;UserMap&quot;属性 1234567&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- column表示数据库的字段名，property表示实体类属性 --&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;user&quot; resultMap=&quot;UserMap&quot;&gt; select *from mybatis.user&lt;/select&gt; ResultMap是Mybatis里面最强大的元素 5、日志5.1日志工厂 曾今：sout，debug 现在：日志 ![1658754024427](C:\\Users\\LRH\\AppData\\Roaming\\Typora\\typora-user-images\\1658754024427.png) 需要掌握的如今只有两个 1. LOG4J（需要导包） 什么是log4j Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码 导包 123456789&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 新建一个log4j.peoperties配置文件 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/logFile.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 测试 12static Logger logger = Logger.getLogger(UserMapperTest.class); 12345public void log4JTest()&#123; logger.info(&quot;info:进入log4JTest方法&quot;); logger.debug(&quot;debug:进入log4JTest方法&quot;); logger.error(&quot;error:进入log4JTest方法&quot;);&#125; &#x3D;&#x3D;Log4j的三种级别&#x3D;&#x3D; 123logger.info(&quot;info:进入log4JTest方法&quot;);logger.debug(&quot;debug:进入log4JTest方法&quot;);logger.error(&quot;error:进入log4JTest方法&quot;); 2.STDOUT_LOGGING(标准的日志工厂，不需要导包)1234&lt;settings&gt; &lt;!-- 标准格式情况下，STDOUT_LOGGING不用导包，不能错任何一个字，尽量到官网复制，不要手写 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; 6、分页6.1使用limit完成分页 接口 12// 分页 List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml 123&lt;select id=&quot;getUserByLimit&quot; resultMap=&quot;UserMap&quot; resultType=&quot;user&quot;&gt; select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt; 测试 1234567891011121314@Testpublic void getUserByLimitTest()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;startIndex&quot;,1); map.put(&quot;pageSize&quot;,2); List&lt;User&gt; userList = mapper.getUserByLimit(map); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 6.2 通过RowBounds实现 接口 12// 分页2，RowBounds实现List&lt;User&gt; getUserByRowBounds(); Mapper.xml 123&lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt; select *from mybatis.user&lt;/select&gt; 测试 1234567891011@Testpublic void getUserByRowBoundsTest()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); RowBounds rowBounds = new RowBounds(1,2); // 从1个下标开始,每页显示2个 List&lt;User&gt; userList = sqlSession.selectList(&quot;com.kuaihua.dao.UserMapper.getUserByRowBounds&quot;, null, rowBounds); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 6.3 分页插件（mybatis pageHelper)了解即可，此处会有详细的使用方式pageHelper 如何使用pageHepler 7、 使用注解开发7.1面向接口编程12345678910111213141516171819202122232425import com.kuaihua.pojo.User;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import java.util.List;import java.util.Map;// 用UserMapper.xml文件代替了UserDaoImpl.java文件，这就是mybatis的最大不同// 这里以后用UserMapper代替，UserDao文件变成UserMapper文件,public interface UserMapper &#123; // 查询所有用户 @Select(&quot;select * from user&quot;) List&lt;User&gt; getUserList(); // 根据id查询数据 @Select(&quot;select * from user where id=#&#123;uid&#125;&quot;) User getUserById(@Param(&quot;uid&quot;) int id); // 添加一个用户 @Insert(&quot;insert into user (id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;) int addUser(User user);&#125; 7.2使用注解开发1234// 根据id查询数据@Select(&quot;select * from user where id=#&#123;uid&#125;&quot;)User getUserById(@Param(&quot;uid&quot;) int id); 7.3CRUD（自动提交事务）12345public static SqlSession getSqlSession()&#123; // 这里设置的是事务自动提交增删改 return sqlSessionFactory.openSession(true);&#125; 自动提交事务 绑定接口，在mybatis-config.xml中注册（两种方式） 123456789&lt;mappers&gt; &lt;mapper resource=&quot;com/kuaihua/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; &lt;!-- 必不可少的过程，绑定接口 --&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.kuaihua.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 测试类 关于使用注解开发 基本类型或者String类型，需要加上 引用类型不需要加上比如（User user) 如果只有一个基本类型，可以忽略，但是建议加上主机@param（””） 在SQL的引用的就是注解的@param（”demo”）中的demo #{} ${} 两个的区别是前者是预编译，所以尽量用#{} 8、LomBok 下载lombok插件 导入lombok 1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注解使用 12345678910111213141516package com.kuaihua.pojo;import lombok.Data;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;@Data // set get，tostring...@AllArgsConstructor // 有参@NoArgsConstructor // 无参public class User &#123; private int id; private String name; private String password;&#125; 1234567891011121314151617181920212223242526下面这些就是可以在lombok中使用的注解，一般常用下面三个 @Data // set get，tostring...@AllArgsConstructor // 有参@NoArgsConstructor // 无参 @Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows@val@varexperimental @var@UtilityClass 9、多对一的处理mybatis-06环境搭建1234567891011121314public class Student &#123; private int id; private String name; // 学生需要关联一个老师 private Teacher teacher;&#125;public class Teacher &#123; private int id; private String name;&#125; 9.1子查询方式12345678910111213141516171819202122232425262728293031&lt;!-- =======================第一种方法:子查询======================--&gt;&lt;!-- 1.获取学生的全部信息 2.通过学生表的&quot;tid&quot;，寻找对应的老师--&gt; &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student; &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!-- property:实体类字段名 column：数据库字段名 association：对象 collection:集合 --&gt; &lt;!-- 复杂的属性单独处理 association：对象 collection:集合 --&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt; 9.2连表查询方式【简单多用】12345678910111213141516&lt;!-- =======================第二种方法：连表查询======================--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeachers&quot;&gt; select s.id sid, s.name sname,s.tid as stid, t.name tname from student s ,teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeachers&quot; type=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;stid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 10、一对多的处理mybatis-07 连表查询处理 123456789101112131415161718192021&lt;!-- 方式二连表查询，个人刚觉比较简单--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid,s.name sname, t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!-- 复杂的对象处理 ， 对象用association ,与javaType搭配使用 集合用collection ，与ofType搭配使用 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 子查询处理 1234567891011&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt; select * from mybatis.teacher where id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select *from mybatis.student where tid=#&#123;tid&#125;;&lt;/select&gt; 小结：1、对象association：对象用association（多对一） 2、集合collection：集合用collection（一对多） 3、javaType&amp;ofType javaType :映射实体类中的属性类型 ofType：指定映射到List或者集合中的pojo类型，泛型中的约束类型 11、动态SQL&#x3D;&#x3D;个人终结&#x3D;&#x3D;:动态sql就是要我们在写slq语句的时候,按照所有条件都满足的一条语句来写就行,只需要把其中的关键字换成对应的标签就行,向逗号之类的符号也不用自己去掉,他会手动帮我们去掉. 所谓的动态SQL就是在sql层面去执行一个逻辑代码. 所谓的逻辑代码无非就是if,where,when,之类的 1234ifchoose (when, otherwise)trim (where, set)foreach 1.环境搭建 1234567CREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB DEFAULT CHARSET=utf8; 2.导包 编写配置文件4.编写实体类5.编写实体类对应的Mapper接口和Mapper.xml文件 If(eg)123456&lt;select&gt; select * from user where 1=1 # 可以搭配map传参,给map传递一个user的参数,这样就可以实现了 &lt;if test=&quot;user != null&quot;&gt; and user=#&#123;user&#125; # and不能省略,后面还可以接续拼接if,同理and也不能省略 &lt;/if&gt;&lt;/select&gt; choose (when, otherwise)1234567891011121314151617&lt;select&gt; select * from user where 1=1 # 可以搭配map传参,给map传递一个user的参数,这样就可以实现了 &lt;where&gt; &lt;choose&gt; &lt;when test = &quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test = &quot;author != null&quot;&gt; title = #&#123;author&#125; &lt;/when&gt; &lt;when test = &quot;view != null&quot;&gt; title = #&#123;view&#125; &lt;/when&gt; # 在这三个选择中,只有一个会被选中 &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; trim (where, set)where标签可以帮我们判断第一个条件是否成立或者存在,如果存在或者成立,就照旧执行,如果不成立,就会把后续语句中的第一个and&#x2F;or删去作为第一个条件,依次拼接后续的条件语句,&#x3D;&#x3D;where的总体作用就是判断第一个词是否是and或者or之类的,如果是就去掉. 12345678910111213&lt;update&gt; update user &lt;set&gt; &lt;if test=&quot;user != null&quot;&gt; and user=#&#123;user&#125;, # 这里的逗号在拼接的时候会自动去掉, &lt;/if&gt; &lt;if test=&quot;user != null&quot;&gt; and user=#&#123;user&#125; # and不能省略,后面还可以接续拼接if,同理and也不能省略 &lt;/if&gt; &lt;/set&gt; where id =#&#123;id&#125;&lt;/update&gt; foreach 1select * from user where 1=1 and(id=1 or id=2 or id=3) 此类就用foreach来完成 Sql片段把sql中公共的部分抽取出来,让代码形成复用 12345678910111213&lt;sql id=&quot;if-user-author&quot;&gt; # 命名方式怎么好用怎么来 &lt;if test=&quot;user != null&quot;&gt; and user=#&#123;user&#125;, # 这里的逗号在拼接的时候会自动去掉, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and user=#&#123;user&#125; # and不能省略,后面还可以接续拼接if,同理and也不能省略 &lt;/if&gt;&lt;/sql&gt;&lt;where&gt; &lt;included refid=&quot;if-user-author&quot;&gt;&lt;/included&gt;&lt;/where&gt; &#x3D;&#x3D;注意事项&#x3D;&#x3D;: 最好基于单表来定义sql片段 不要存在标签 12、缓存 MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制 默认情况下，只启用了本地的会话缓存（一级缓存），它仅仅对一个会话中的数据进行缓存 12.1、什么是缓存：大致关系图 12.2、一级缓存(默认情况下是开启的)12&lt;!-- 在设置中开启缓存 --&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 12.3、二级缓存(从一级缓存上接收过来)123&lt;!--开启二级缓存--&gt;&lt;cache /&gt; 也可以自定义一些二级缓存属性 12345&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 配置解析 这个更高级的配置创建了一个 FIFO 缓存 每隔 60 秒刷新 最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 `LRU` – 最近最少使用：移除最长时间不被使用的对象。 FIFO– 先进先出：按对象进入缓存的顺序来移除它们。 `SOFT` – 软引用：基于垃圾回收器状态和软引用规则移除对象。 `WEAK` – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 12.4、小结 只要开启了二级缓存，只要在同一个mapper下都有效 所有的数据都会先放在一级缓存 只有在会话提交或者关闭的时候才会从一级缓存提交到二级缓存","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://kuai-hua.github.io/categories/Mybatis/"}],"tags":[]},{"title":"常见软件问题","slug":"常见软件问题","date":"2022-11-09T03:12:46.000Z","updated":"2022-11-09T03:58:47.171Z","comments":true,"path":"2022/11/09/常见软件问题/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E9%97%AE%E9%A2%98/","excerpt":"Idea卡在Resolving Maven dependencies的解决方案在Reimpot All Maven Porjects时, 如果项目过大, maven依赖过多, 会直接卡在Resolving Maven dependencies这步 1修改maven Importing的jvm参数, 默认为700多, 直接修改成 -Xms1024m -Xmx2048m","text":"Idea卡在Resolving Maven dependencies的解决方案在Reimpot All Maven Porjects时, 如果项目过大, maven依赖过多, 会直接卡在Resolving Maven dependencies这步 1修改maven Importing的jvm参数, 默认为700多, 直接修改成 -Xms1024m -Xmx2048m 关闭占用端口8080为例子 查看端口被占用的进程号 1netstat -ano|findstr &quot;8080&quot; 查看端口“8080”被哪个应用程序占用 1tasklist|findstr &quot;14384&quot; xxxxxxxxxx7 1.post-body p a{2 color: #0000FF; # 蓝色3 border-bottom: none; # 下划线4 &amp;:hover{5 color: #FF0000; # 红色6 }7}bash 123456按进程号杀死进程： takskill /pid 进程号按进程号杀死多个进程： taskkill /pid 进程号1 /pid 进程号2按进程名杀死进程： taskkill /im 进程名按进程名杀死多个进程： taskkill /im 进程名1 /im 进程名2如果关闭杀死所有进程：（使用通配符） taskkill /im *.exe强制终止进程： taskkill /f 进程名或进程号","categories":[],"tags":[]},{"title":"常用的注解及其意义","slug":"注解","date":"2022-11-09T03:10:13.000Z","updated":"2022-11-16T14:16:03.529Z","comments":true,"path":"2022/11/09/注解/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/%E6%B3%A8%E8%A7%A3/","excerpt":"springboot中常用注解跟意思 @Autowired：表示自动注入，自动从spring的上下文&#x3D;&#x3D;找到合适的bean来注入&#x3D;&#x3D; @Resource：表示按指定名称注入，@Resource 可以通过 byName 和 byType的方式注入， 默认先按 byName的方式进行匹配，如果匹配不到，再按 byType的方式进行匹配。 当然，还可以为 @Service和@Resource 添加 name 这个属性来区分不同的实现。","text":"springboot中常用注解跟意思 @Autowired：表示自动注入，自动从spring的上下文&#x3D;&#x3D;找到合适的bean来注入&#x3D;&#x3D; @Resource：表示按指定名称注入，@Resource 可以通过 byName 和 byType的方式注入， 默认先按 byName的方式进行匹配，如果匹配不到，再按 byType的方式进行匹配。 当然，还可以为 @Service和@Resource 添加 name 这个属性来区分不同的实现。 @Component：表示一种泛指，被标记类即组件，Spring扫描注解配置时，会标记这些类要&#x3D;&#x3D;生成对应的bean。&#x3D;&#x3D; Controller、Service、、Repository分别作用类是控制层类、业务层类、数据访问层类，Spring扫描注解配置时，会标记这些类要生成对应的bean。 @Autowired和@Resource是用来修饰字段，构造函数，或者方法，其作用是注入bean。而@Service，@Controller，@Repository， ​ @Component则是用来修饰类，标记这些类要生成bean。 @Component 组件，为了被扫描到可以在实体类中加 @ConfigurationProperties(prefix &#x3D; “person”) 把application.yaml中的默认属性填装到Person类中的对应关键字 123@Service // service层@Mapper@Repository // mapper/dao层@Controller // controller层 元注解 自己定义注解1234567891011121314151617181920212223242526272829303132333435363738394041import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;// 自己定义注解和使用注解public class Demo01 &#123; @MyAnnotation01(&quot;A&quot;) @MyAnnotation02 @MyAnnotation03(name = &quot;B&quot;) public void Test()&#123; &#125;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)// 表示这个注解在什么地方有效,级别runtime&gt;class&gt;sources,runtime说明程序运行都有效,一般选这个,@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation01&#123; String value(); // 这表示定义了一个叫做MyAnnotation01的注解,这个注解默认有一个值,这个值得手动去赋值 // 类似于@Mapper之类的注解,可以使用@MyAnnotation01来使用&#125;@interface MyAnnotation02&#123; String value() default &quot;server.port&quot;; // 可以不手动赋值,默认值为&quot;server.port&quot;&#125;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation03&#123; // 注解参数: 参数类型 + 参数名字() + default + 默认值类型的值 // 注解参数: 参数类型 + 参数名字() String name() default &quot;&quot;; int id() default -1; int age() default 4; String[] schools() default &#123;&quot;name&quot;,&quot;id&quot;&#125;;&#125; 反射优点:可以通过反射来获取Class的包名,类名,方法名等,动态创建对象执行操作执行方法 缺点:降低程序的运行效率,可以关闭程序的安全监测访问操作私有变量,有安全隐患, Class.forname(“具体的包名”) 通过对比hashCode来判断是否是同一个类 invoke()方法","categories":[],"tags":[]},{"title":"VMware配置","slug":"VMware配置","date":"2022-11-09T03:08:04.000Z","updated":"2022-11-09T03:58:36.071Z","comments":true,"path":"2022/11/09/VMware配置/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/VMware%E9%85%8D%E7%BD%AE/","excerpt":"虚拟机连网操作","text":"虚拟机连网操作","categories":[{"name":"VMware","slug":"VMware","permalink":"https://kuai-hua.github.io/categories/VMware/"}],"tags":[]},{"title":"springMVC学习","slug":"springMVC学习","date":"2022-11-09T03:06:21.000Z","updated":"2022-11-09T03:58:05.806Z","comments":true,"path":"2022/11/09/springMVC学习/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/springMVC%E5%AD%A6%E4%B9%A0/","excerpt":"1、SpringMvc的框架和配置模板1.1、Mapper配置模板12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuaihua.dao.UserDao&quot;&gt; &lt;!--这里的id是com.kuaihua.dao.UserDao类下的getUserList方法，resultType是返回值类型，必须写成实体类--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuaihua.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt;","text":"1、SpringMvc的框架和配置模板1.1、Mapper配置模板12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuaihua.dao.UserDao&quot;&gt; &lt;!--这里的id是com.kuaihua.dao.UserDao类下的getUserList方法，resultType是返回值类型，必须写成实体类--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuaihua.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 2、resources下面的配置信息，常用，一般写死的applicationContext.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt; &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt; &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;&lt;/beans&gt; database.properties1234jdbc.driver = com.mysql.cj.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/ssmbuild?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaijdbc.username = rootjdbc.password = 88888 mybatis-config.xml1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuaihua.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.kuaihua.dao.BooksMapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; spring-dao.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1.关联数据库配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!--配置数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--绑定mybatis配置文件，也就是spring配置mybatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!--4、配置dao接口扫描包，动态的实现Dao接口可以注入到Spring容器中，这一步在原来的spring中是实现一个Impl接口来实现sqlSession的注入，这里Spring直接帮我们做了--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--注入sqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--自动扫描dao的包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.kuaihua.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spring-mvc.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1、注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2、静态资源过滤器--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3、自动扫描包--&gt; &lt;context:component-scan base-package=&quot;com.kuaihua.controller&quot;/&gt; &lt;!--4、视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spring-service1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1扫描Service下的所有包，这里用配置，一般用注解@Service--&gt; &lt;context:component-scan base-package=&quot;com.kuaihua.service&quot;/&gt; &lt;!--2将我们所有业务类，注入到Spring，可以通过配置或者注解实现，这里用配置--&gt; &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.kuaihua.service.BookServiceImpl&quot;&gt; &lt;property name=&quot;booksMapper&quot; ref=&quot;booksMapper&quot;/&gt; &lt;/bean&gt; &lt;!--3声明式事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;!-- 4、aop支持--&gt;&lt;/beans&gt; 3、常用的依赖和静态资源导出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!-- 依赖：junit,数据库驱动，连接池，servlet,jsp,mybatis,mybatis-spring,spring--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;!--按需求添加--&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;!--按需求添加--&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;","categories":[{"name":"SpringMvc","slug":"SpringMvc","permalink":"https://kuai-hua.github.io/categories/SpringMvc/"}],"tags":[]},{"title":"springCloud学习","slug":"springCloud学习","date":"2022-11-09T03:03:08.000Z","updated":"2022-11-09T03:57:48.692Z","comments":true,"path":"2022/11/09/springCloud学习/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/springCloud%E5%AD%A6%E4%B9%A0/","excerpt":"springcloud笔记1.Eureka(尤里卡)1.1 pom.xml(依赖)1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;","text":"springcloud笔记1.Eureka(尤里卡)1.1 pom.xml(依赖)1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 1.2application.yml1234567891011server: port: 7001eureka: instance: hostname: localhost # Eureka服务端的实例名称 client: register-with-eureka: false # 表示是否想Eureka服务中心注册自己 fetch-registry: true # 如果为false ,表示自己就是注册中心,但是一般都是true,Eureka的作用是维护,不是注册 service-url: # 监控页面 defaultZone: https://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 1.3 使用Eureka,访问https://localhost:7701/eureka 就可以访问到Eureka的配置页面1234567891011121314package com.kuaihua.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServer // 一般都是开启功能就好,大部分代码都是写好的,这就是服务的public class EurekaServer_7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer_7001.class,args); &#125;&#125; 1234567891011121314151617package com.kuaihua.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;// 手写springboot的启动类@SpringBootApplication@EnableEurekaClient // 自动在服务启动后自动注册到Eureka中,这是客户端,开启后就可以自动显示在服务端@EnableDiscoveryClient // 开启获取服务信息public class DeptProvider_8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider_8001.class,args); &#125;&#125; 服务注册与发现 集群的配置与实现 12345678910111213server: port: 7001eureka: instance: hostname: localhost # Eureka服务端的实例名称,这个得去改host文件 instance-id: client: register-with-eureka: false # 表示是否想Eureka服务中心注册自己 fetch-registry: false # 如果为false ,表示自己就是注册中心,但是一般都是true,Eureka的作用是维护,不是注册 service-url: # 监控页面# defaultZone: https://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ # 这里可以添加多个地址,这样就可以搭建集群了,但是因为要改host地址就不做演示 defaultZone: http://localhost:7002/eureka/,http://localhost:7003/eureka 1234567891011121314151617181920212223242526272829303132server: port: 8001# mybatis配置mybatis: type-aliases-package: com.kuaihua.springcloud.pojo mapper-locations: classpath:mybatis/mapper/*.xml config-location: classpath:mybatis/mybatis-config.xml# spring配置包括数据源spring: application: name: springcloud-provider-dept-8001 datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai username: root password: 888888# 服务会被注册在哪里eureka: client: service-url: defaultZone: http://localhost:7001/eureka/,http://localhost:7002/eureka/,http://localhost:7003/eureka/ instance: instance-id: springcloud-provider-dept8001 # 修改默认的描述信息info: app.name: kuaihua company.name: www.baidu.com CAP原则与Zookeeper的区别 2. Ribbon2.1负载均衡 个人理解:所谓的负载均衡就是客户端从已经想Eureka注册的服务端中选取其中合适的服务提供者给客户端的一种过程,为了防止服务器的雪崩,一般设置多个服务器,形成分布式集群,这样就会在即使一个服务器崩了的情况下,客户仍然可以得到自己想要的结果. 2.2 与Feign的区(面向接口)Ribbon 面向微服务名字编程 Feign 面向接口编程 3.Hystrix(熔断,降级)熔断:服务器 某个服务器异常,引起熔断 ,引起熔断,保险丝 服务降级 客户端,从整体网站请求负载考虑 当某个服务熔断或者关闭后,服务将不再被调用 此时客户端仍然可以准备一个FallbackFactory,返回一个默认值,整体的服务水平下降了,但是好歹可以用,比直接404强. Dashboard流监控 4.zuul(路由网关)目前理解:可以隐藏自己的真实访问地址,可以更改服务链接的前缀 12345678910111213141516package com.kuaihua.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableZuulProxy // 一般都用代理EnableZuulProxy,不用服务EnableZuulServer,只需要开启就行,代码一般都是编写好的public class ZuulApplication9527 &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication9527.class,args); &#125;&#125; 12345678910111213141516171819202122232425server: port: 9527spring: application: name: springcloud-zuuleureka: client: service-url: defaultZone: http://localhost:7001/eureka/ instance: instance-id: zuul9527.com prefer-ip-address: trueinfo: app.name: KUAIHUA company.name: hh.comp# zuul的作用,隐藏真实的服务器名字springcloud-provider-dept-8001 可以用mydept来替换zuul: routes: myDept.serviceId: springcloud-provider-dept-8001 myDept.path: /mydept/** ignored-services: springcloud-provider-dept-8001 # 表示忽略这个地址的访问要求,只能使用mydept/**去访问,这样就可以隐藏微服务的真实地址了 prefix: /kuaihua # 配置公共的访问前缀,localhost:8080/kuaihua/dept/**才可以访问,不然不能访问,一般真实的访问就需要,实验环境不需要 5.Config&#x3D;&#x3D;为所有环节提供一个中心化配饰&#x3D;&#x3D; 5.1 远程链接git ,yml配置12345678910server: port: 3344spring: application: name: springcloud-config-server cloud: config: server: git: uri: https://gitee.com/kuaihua/springcloud-config.git # 这个是https链接，不是git链接 客户端远程调用远端服务器 远程配置与实现 6.rest学习环境搭建(关键字:RestTemplate)123456789101112131415package com.kuaihua.springcloud.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ConfigBean &#123; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package com.kuaihua.springcloud.controller;import com.kuaihua.springcloud.pojo.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.List;@RestControllerpublic class DeptConsumerController &#123; @Autowired private RestTemplate restTemplate; // 这就是一个提供多种远程访问http的方法,简单的Restful服务模板 // 从远端拿到数据,一般前缀都是通用的,直接设置差一个常量 // 一般的形式都是这样的restTemplate.getForObject(url,实体类:Map(传输对象),response.class(返回的数据)) private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;; @RequestMapping(&quot;/consumer/get/&#123;id&#125;&quot;) public Dept get(@PathVariable(&quot;id&quot;)Long id)&#123; // 通过拼接的方式形成url,getForObject(url(从哪个远端url拿到想要的数据),响应对象(返回对象); return restTemplate.getForObject(REST_URL_PREFIX+&quot;/dept/get/&quot;+id,Dept.class); &#125; @RequestMapping(&quot;/consumer/add&quot;) public boolean add(Dept dept)&#123; // 通过拼接的方式形成url,getForObject(url(从哪个远端url拿到想要的数据),响应对象(返回对象); return restTemplate.postForObject(REST_URL_PREFIX+&quot;/dept/add&quot;,dept,Boolean.class); &#125; @RequestMapping(&quot;/consumer/list&quot;) public List&lt;Dept&gt; queryAll()&#123; // 通过拼接的方式形成url,getForObject(url(从哪个远端url拿到想要的数据),响应对象(返回对象); return restTemplate.getForObject(REST_URL_PREFIX+&quot;/dept/list&quot;,List.class); &#125;&#125;","categories":[{"name":"springcloud","slug":"springcloud","permalink":"https://kuai-hua.github.io/categories/springcloud/"}],"tags":[]},{"title":"Spring5的学习","slug":"Spring5的学习","date":"2022-11-09T02:59:14.000Z","updated":"2022-11-09T04:07:46.936Z","comments":true,"path":"2022/11/09/Spring5的学习/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/Spring5%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"1、Spring1.1、常用的仓库123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.21&lt;/version&gt;&lt;/dependency&gt;","text":"1、Spring1.1、常用的仓库123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.21&lt;/version&gt;&lt;/dependency&gt; 1.2、优点 免费开源的框架（容器 轻量级的，非入侵式的框架 控制反转（IOC），面向切面编程（AOP） 支持事务处理，对框架整合的支持 总结一句话：Spring是一个轻量级的控制反转（IOC）和面向切面编程的框架（AOP） 1.3、组成拓展： 原因：大多数公司都是基于SpringBoot进行快速开发的，学习SpringBoot的前提是得学会Spring跟SpingMVC 2、第一个SPring程序2.1、常用的测试语句12345678910111213141516package com.kuaihua;import com.kuaihua.pojo.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Object id名字 = context.getBean(&quot;id名字&quot;); System.out.println(student.getName()); &#125;&#125; 2.2、常用的配置123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; (1) (2) &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 123456789101112driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/数据库名称?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaiusername=rootpassword=root// 以下两个可以不写// 连接池启动时创建的初始化连接数量（默认值为0）initialSize=2 // 连接池中可同时连接的最大的连接数maxActive=10 3、注入方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;bean id=&quot;address&quot; class=&quot;com.kuaihua.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;广东&quot;/&gt;&lt;/bean&gt;&lt;!-- 相当于Student student = new Student(); 这里的student 就是下面的id --&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kuaihua.pojo.Student&quot;&gt; &lt;!--第一种：普通值注入 value--&gt; &lt;property name=&quot;name&quot; value=&quot;快画&quot;/&gt; &lt;!--第二种：bean注入 ref--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!-- 数组 --&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- List --&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;看小说&lt;/value&gt; &lt;value&gt;打游戏&lt;/value&gt; &lt;value&gt;敲代码&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Map --&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;132154654654&quot;/&gt; &lt;entry key=&quot;密码&quot; value=&quot;1321245&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- Set --&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;sss&lt;/value&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- Null --&gt; &lt;!--这里是空串，下面是null &lt;property name=&quot;wife&quot; value=&quot;&quot;&gt;&lt;/property&gt;--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--Property--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/数据库名称?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;888888&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3.1、构造器注入3.2、Set方式注入【重要】3.2.1、普通值注入1&lt;!--第一种：普通值注入 value--&gt;&lt;property name=&quot;name&quot; value=&quot;快画&quot;/&gt; 3.2.2、bean注入1&lt;!--第二种：bean注入 ref--&gt;&lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; 3.2.3、数组123456789&lt;!-- 数组 --&gt;&lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 3.2.4、List12345678&lt;!-- List --&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;看小说&lt;/value&gt; &lt;value&gt;打游戏&lt;/value&gt; &lt;value&gt;敲代码&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 3.2.5、Map1234567&lt;!-- Map --&gt;&lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;132154654654&quot;/&gt; &lt;entry key=&quot;密码&quot; value=&quot;1321245&quot;/&gt; &lt;/map&gt;&lt;/property&gt; 3.2.6、Set12345678&lt;!-- Set --&gt;&lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;sss&lt;/value&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 3.2.7、Null12345&lt;!-- Null --&gt;&lt;!--这里是空串，下面是null &lt;property name=&quot;wife&quot; value=&quot;&quot;&gt;&lt;/property&gt;--&gt;&lt;property name=&quot;wife&quot;&gt; &lt;null/&gt;&lt;/property&gt; 3.2.8、Property123456789&lt;!--Property--&gt;&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/数据库名称?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;888888&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 3.3、拓展方式注入3.3.1、p命名空间12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间注入，可以直接注入属性值,类似与property标签--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kuaihua.pojo.User&quot; p:name=&quot;快画&quot; p:age=&quot;22&quot; /&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.kuaihua.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;kuaihua&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; 3.3.2、c命名空间12345678&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--c命名空间注入，通过构造器注入：construct-args--&gt; &lt;bean id=&quot;user3&quot; class=&quot;com.kuaihua.pojo.User&quot; c:name=&quot;我是C&quot; c:age=&quot;20&quot;/&gt; 测试 1234567public class TestPAndC &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userBean.xml&quot;); User user = (User) context.getBean(&quot;user2&quot;); System.out.println(user); &#125;&#125; 注意点 c命名和p命名空间不能直接使用，需要导入xml约束 12xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 4、Bean作用域4.1、单例模式（Spring 的默认机制）1&lt;bean id=&quot;user&quot; class=&quot;com.kuaihua.pojo.User&quot; p:name=&quot;快画&quot; p:age=&quot;22&quot; scope=&quot;singleton&quot;/&gt; 4.2、原型模式1&lt;bean id=&quot;user&quot; class=&quot;com.kuaihua.pojo.User&quot; p:name=&quot;快画&quot; p:age=&quot;22&quot; scope=&quot;prototype&quot;/&gt; 4.3、其它模式：request,session,application,这些只能在web中应用5、Bean的自动装配 自动装配式Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性 5.1、三种装配方式 在xml中显示 在java中显示 隐式的自动装配bean【重要】 5.2、环境搭建 一个人有两个宠物，一个猫，一个狗 12345678910111213141516171819202122232425262728293031public class Dog &#123; public void shout()&#123; System.out.println(&quot;wang~&quot;); &#125;&#125;package com.kuaihua.pojo;public class Cat &#123; public void shout()&#123; System.out.println(&quot;miao~&quot;); &#125;&#125;package com.kuaihua.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class People &#123; private Cat cat; private Dog dog; private String name;&#125; 5.3、测试：5.3.1、byName1234567891011&lt;bean id=&quot;cat&quot; class=&quot;com.kuaihua.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.kuaihua.pojo.Dog&quot;/&gt;&lt;!-- byName：会在容器上下查找，和自己对象set方法后面的值对应的beanid自动装配【注意，bean的id必须与beanid相同】 byType：会在容器上下查找，和自己对象属性类型相同的自动装配【注意，bean的class必须与唯一，id可以想写啥就写啥】--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.kuaihua.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;快画&quot;/&gt;&lt;/bean&gt; 5.3.2、byType12345678910111213 &lt;bean id=&quot;cat&quot; class=&quot;com.kuaihua.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog1312&quot; class=&quot;com.kuaihua.pojo.Dog&quot;/&gt; &lt;!-- byName：会在容器上下查找，和自己对象set方法后面的值对应的beanid自动装配【注意，bean的id必须与beanid相同】 byType：会在容器上下查找，和自己对象属性类型相同的自动装配【注意，bean的class必须与唯一，id可以想写啥就写啥】 --&gt; &lt;bean id=&quot;people&quot; class=&quot;com.kuaihua.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;快画&quot;/&gt; &lt;/bean&gt; 测试代码 1234567891011121314import com.kuaihua.pojo.People;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); People people = context.getBean(&quot;people&quot;, People.class); people.getCat().shout(); people.getDog().shout(); &#125;&#125; 5.4、注解实现自动装配@Autowire注意： 1.导入约束 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--要使用注解就要导入这些配置--&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 2.导入注解支持 1&lt;context:annotation-config/&gt; 6、使用注解说明(Spring-04-anno) @Autowired 先ByType然后ByName 如果Autowired不能唯一自动装配，需要通过@Qualifier(value &#x3D; “XXX”)来辅助现实装配 @Resource 先ByName然后ByType @Nullable 说明这个可以为空值 区别：顺序不同 @Component 组件 ，类似与 其衍生出来的注释： dao 【@Repository】 service 【@Service】 controller【@Controller】这四个的注解功能都是一样的，都是将某个类注册到Spring中，装配Bean @Scope(“prototype&#x2F;singleton”) 表示作用域 @@Value(“快画”) 类似与 配置：12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--指定要要扫描的包，这个包下的注解才会生效--&gt; &lt;context:component-scan base-package=&quot;com.kuaihua.pojo&quot;/&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 代码：1234567891011// 等价与&lt;bean id=&quot;user&quot; class=&quot;com.kuaihua.pojo.User&quot;/&gt;// @Component 组件@Component@Scope(&quot;prototype&quot;)public class User &#123; // @Value(&quot;快画&quot;) public String name;&#125; 测试：1234567public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); System.out.println(user.name); &#125;&#125; 小结： ![1659446681829](C:\\Users\\LRH\\AppData\\Roaming\\Typora\\typora-user-images\\1659446681829.png) xml与注解 xml更加万能，适用于任何场合，维护简单方便 注解 不是自己的类使用不了 xml与注解最佳实践： xml用来管理bean 注解只负责完成属性的注入 使用过程中应该注意，要是注解生效必须开启注解支持 123&lt;!--指定要要扫描的包，这个包下的注解才会生效--&gt;&lt;context:component-scan base-package=&quot;com.kuaihua.pojo&quot;/&gt;&lt;context:annotation-config/&gt; 7、用java的方式实现Spring中Bean的配置（后期了解，这玩意再SpringBoot中随处可见）链接：https://www.bilibili.com/video/BV1WE411d7Dv?p=15&amp;vd_source=5bc0b5059f81912a65b515bad837a983 8、代理模式（SpringAOP 相关）Spring-05-proxy学习的原因：涉及SpringAOP的底层 8.1、静态代理角色分析： 抽象角色：一般使用接口或者抽象类来结局 真实角色：被代理的人 代理角色：代理真实的角色，代理真实角色后，一般会有一些附属操作，类似现实中的中介，收中介费，带客户看房之类的 客户：访问代理对象的人 代码实现步骤： 接口 12345public interface Rent &#123; public void rent();&#125; 真实角色 12345678public class Host implements Rent&#123; @Override public void rent() &#123; System.out.println(&quot;房东要出租房子&quot;); &#125;&#125; 代理角色 123456789101112131415161718192021222324252627282930313233public class Proxy implements Rent&#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; @Override public void rent() &#123; seeHouse(); host.rent(); heTong(); fare(); &#125; private void fare()&#123; System.out.println(&quot;中介收取中介费&quot;); &#125; private void seeHouse()&#123; System.out.println(&quot;中介带客户看房子&quot;); &#125; private void heTong()&#123; System.out.println(&quot;中介帮助代理房东签合同&quot;); &#125;&#125; 客户端访问代理角色 1234567891011121314package com.kuaihua.demo01;public class Client &#123; public static void main(String[] args) &#123; // 房东要出租房子 Host host = new Host(); // 代理，中介，帮助房东出租房子，但是他要左一些附属操作，比如收费用，带客户看房子 Proxy proxy = new Proxy(host); // 不用面对房东就可以租到房子 proxy.rent(); &#125;&#125; 代理的好处： 可以使真实的角色更加纯粹，不用关注多余的公共业务 公共业务交给代理，实现了业务分工 公共业务发送扩展的时候，方便集中管理 缺点： 一个真实的角色就会产生一个代理角色，代码量会翻倍，开发效率贬低 8.2、动态代理Spring-05-proxy demo04工具类 12345678910111213141516171819202122232425262728293031323334353637import com.kuaihua.Demo03.Rent;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyInvocationHandler implements InvocationHandler &#123; private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; // 生成代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this); &#125; // 处理代理实例，并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); // 动态代理的本质就是使用反射机制实现 Object result = method.invoke(target,args); return result; &#125; public void log(String msg)&#123; System.out.println(&quot;使用了&quot;+msg+&quot;方法&quot;); &#125;&#125; 真实角色 12345678910111213141516171819202122232425// 类似房东，一个真实角色public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 接口 12345678910// 这是要实现的业务public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 测试代码 12345678910111213141516171819202122package com.kuaihua.demo04;import com.kuaihua.demo02.UserService;import com.kuaihua.demo02.UserServiceImpl;public class Client&#123; public static void main(String[] args) &#123; // 真实角色 UserServiceImpl userService = new UserServiceImpl(); // 代理角色，不存在 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); // 生成一个代理类 UserService proxy = (UserService) pih.getProxy(); proxy.delete(); &#125;&#125; 8.3 增加理解9、&#x3D;&#x3D;AOP（重点，面向切面编程）三种方式&#x3D;&#x3D;仓库 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;public class Log implements MethodBeforeAdvice &#123; // method 要执行目标参数的方法 // args 参数 // target 目标参数 public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName()+&quot;方法的&quot;+method.getName()+&quot;被执行了&quot;); &#125;&#125; 第一种：代码 123456789101112import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;public class After implements AfterReturningAdvice &#123; @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法，执行结果为：&quot;+returnValue); &#125;&#125; 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.kuaihua.pojo.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.kuaihua.log.Log&quot;/&gt;&lt;bean id=&quot;after&quot; class=&quot;com.kuaihua.log.After&quot;/&gt;&lt;!-- 方式一：通过原生的Spring Api实现--&gt;&lt;!-- 配置aop，需要导入aop约束--&gt;&lt;aop:config&gt; &lt;!--pointcut：切入点 execution 切入点位置 execution(* com.kuaihua.pojo.UserServiceImpl.*(..)) 切入点为com.kuaihua.pojo.UserServiceImpl下的所有方法，(..)表示参数有多 --&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuaihua.pojo.UserServiceImpl.*(..))&quot;/&gt; &lt;!-- 执行方法环绕--&gt; &lt;!--aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; 意思是把代号为log的类切入到代号为pointcut的类里面 --&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;after&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; 第二种：代码 123456789public class DiyPointCut &#123; public void Before()&#123; System.out.println(&quot;========方法执行前Before&quot;); &#125; public void After()&#123; System.out.println(&quot;========方法执行后After&quot;); &#125;&#125; 12345678910111213&lt;bean id=&quot;diy&quot; class=&quot;com.kuaihua.diy.DiyPointCut&quot;/&gt;&lt;aop:config&gt; &lt;!--自定义切面 ref 表示要引入的类 --&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入面的位置--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.kuaihua.pojo.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before method=&quot;Before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;After&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 第三种：代码 1234567891011121314151617181920212223242526272829303132// 方式三：使用注解来完成import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspect // 标志这个类是一个切面public class AnnotationPointCut &#123;// 方式三使用注解来完成AOP操作 @Before(&quot;execution(* com.kuaihua.pojo.UserServiceImpl.*(..))&quot;) public void Before()&#123; System.out.println(&quot;方法执行前=======&quot;); &#125; @After(&quot;execution(* com.kuaihua.pojo.UserServiceImpl.*(..))&quot;) public void After()&#123; System.out.println(&quot;方法执行后=======&quot;); &#125; @Around(&quot;execution(* com.kuaihua.pojo.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前===========&quot;); Signature signature = jp.getSignature(); // 获得签名 System.out.println(&quot;signature:&quot;+signature); Object proceed = jp.proceed(); System.out.println(&quot;环绕后===========&quot;); System.out.println(&quot;proceed:&quot;+proceed); &#125;&#125; 123456&lt;!--方式三--&gt;&lt;bean id=&quot;annotation&quot; class=&quot;com.kuaihua.diy.AnnotationPointCut&quot;/&gt;&lt;!--开启注解支持--&gt;&lt;aop:aspectj-autoproxy/&gt; 10、整合Mybatis10.1、实体类pojo1234567891011121314import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private String password; private int age;&#125; 10.2、接口类1234567891011package com.kuaihua.mapper;import com.kuaihua.pojo.User;import java.util.List;public interface UserMapper &#123; public List&lt;User&gt; selectStudent();&#125; 10.3、接口mapper文件12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuaihua.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectStudent&quot; resultType=&quot;User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 10.4、配置spring-dao.xml,这里的配置基本固定，不需要修改1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--这里配置的是一些不用修改的文件，固定配置--&gt; &lt;!--要使用注解就要导入这些配置--&gt; &lt;context:annotation-config/&gt; &lt;!--DataSource 用Spring的数据源代替Mybatis的数据源 配置： c3p0,dbcp,druid 我们这里使用Spring提供的JDBC :org.springframework.jdbc.datasource --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;888888&quot;/&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!--绑定Mybatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuaihua/mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能通过构造器注入sqlSessionFactory，因为它没有set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 10.5、配置mybatis.config.xml【名存实亡】，大部分配置都转移到了spring-dao.xml中这个类主要就是用于编写一些配置文件，比如settings，别名管理等等 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!--别名管理--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuaihua.mapper&quot;/&gt; &lt;package name=&quot;com.kuaihua.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;/configuration&gt; 10.6、接口的实现类【***Impl.java】多的，有两种方式这个实现类是多的，用来实现sqlSession的注入 1234567891011121314151617181920212223// 第一种package com.kuaihua.mapper;import com.kuaihua.pojo.User;import org.mybatis.spring.SqlSessionTemplate;import java.util.List;public class UserMapperImpl implements UserMapper&#123; private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;User&gt; selectStudent() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectStudent(); &#125;&#125; 1234&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能通过构造器注入sqlSessionFactory，因为它没有set方法，所以也要设置set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; 123&lt;bean id=&quot;userMapper&quot; class=&quot;com.kuaihua.mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; &#x3D;&#x3D;第二种，好用，set方法已经被封装好，不用自己写&#x3D;&#x3D; 123456789101112131415161718192021222324package com.kuaihua.mapper;import com.kuaihua.pojo.User;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import java.util.List;public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper&#123; @Override public List&lt;User&gt; selectStudent() &#123; /* SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectStudent(); */ return getSqlSession().getMapper(UserMapper.class).selectStudent(); &#125;&#125; 123&lt;bean id=&quot;userMapper2&quot; class=&quot;com.kuaihua.mapper.UserMapperImpl2&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; 10.7、applicationContext.xml把spring-dao.xml，mybatis.config.xml导入文件中，这个主要配置bean1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;!--专著注册一--&gt; &lt;bean id=&quot;userMapper&quot; class=&quot;com.kuaihua.mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;userMapper2&quot; class=&quot;com.kuaihua.mapper.UserMapperImpl2&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 10.8、编写测试类123456789101112131415161718import com.kuaihua.mapper.UserMapper;import com.kuaihua.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class DaoTest &#123; @Test public void MyTest()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class); for (User user : userMapper.selectStudent()) &#123; System.out.println(user); &#125; &#125;&#125; 11、事务事务ACID&#x3D;&#x3D;四大原则&#x3D;&#x3D;： 原子性 一致性 隔离性 多个事务操作同一个资源，防止被影响 持久性 一旦事务提交，无论系统发生什么，数据都不会发生改变 特点 把一组事务当做一个事务来做，要么都成功，要么都失败 &#x3D;&#x3D;事务开发过程中，非常重要，涉及数据的一致性问题&#x3D;&#x3D; 确保数据的完整性和一致性 通过AOP操作来植入事务操作，基本写死的123456789101112131415161718192021222324252627 &lt;!--通过AOP方式植入--&gt; &lt;!--配置声明式事务--&gt; &lt;!--transactionManager这个东西Spring帮我们写好了，直接用就行--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--&lt;constructor-arg ref=&quot;dataSource&quot; /&gt;--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;select&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!--一般只要写这一句就行，上面方便回顾&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- AOP植入--&gt; &lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.kuaihua.mapper.*.*(..))&quot;/&gt; &lt;!--切入--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt; &lt;/aop:config&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://kuai-hua.github.io/categories/Spring/"}],"tags":[]},{"title":"Mysql相关笔记","slug":"Mysql相关笔记","date":"2022-11-09T02:55:51.000Z","updated":"2022-12-08T11:51:28.820Z","comments":true,"path":"2022/11/09/Mysql相关笔记/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/Mysql%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/","excerpt":"Mysql笔记1.关于时间的数据类型","text":"Mysql笔记1.关于时间的数据类型 CRUD12345678910111213141516171819202122232425262728293031323334创建数据库: create database 数据库名称;选中数据库操作: use 数据库名称;查看某个数据库中的数据表 show tables;创建数据表操作: crate table 数据表名称( name varchar(20), owner varchar(20), species varchar(20), sex char(1), birth date, death DATE; )查看创建好的数据表的结构: describe 数据表名称;查看表中的数据 select * form 数据表;往数据表中添加数据 INSERT INTO 数据表 VALUES(&#x27;Puffball&#x27;,&#x27;Diane&#x27;,&#x27;hamster&#x27;,&#x27;f&#x27;,&#x27;1990-3-8&#x27;,NULL)删除数据表的特定内容 delete form 数据表 where 要删除的数据的某一个符号 = &#x27;符号的值&#x27;修改i数据库的内容: update 数据表 set要修改为的值 where 要修改的那一条数据的判别符号,如name,的限制下标 select * from user limit 0,3 # 查询user表第0到3,用来分页的时候,0和3可以使用map来存储,实现分页操作 约束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566671-主键约束: 它可以唯一确定一张表中的一条记录,使得该字段不重复且不为空 create table user( id int primary key, name varchar(20) );2-联合主键约束: create table user2( id int, name varchar(20), password varchar(20), primary key(id, name) );3- 自增约束:create table user3( id int primary key auto_increment, //在数据表中id自动增加 name varchar(20) );插入方式:insert into user3(name) values(&quot;zhangsna&quot;);修改表的结构 添加主键约束 alter table 表的名称 add 约束形式(在哪里添加); 删除主键约束 alter tabla 表的名称 drop 约束形式(在哪里删除); 修改主键约束 alter table 表的名称 modify 修改的字段 修改的约束形式;4-唯一约束:约束修饰字段的值不可以重复,组合起来不重复就可以 create table user5( id int, name varchar(20), unique(name) //修饰字段不可以重复 ); 或者 create table user5( id int, name varchar(20) ); alter table user5 add unique(name);5-非空约束:约束值不能为空 crate table 表的名称( id int, name varchar(20) not null );6-默认约束:插入字段值时如果没有传值就会使用默认值 create table user( id int , name varchar(20), age int dafault 19 // age 的默认就是19 );7-外键约束:最起码需要两张表,主表和副标 create table classes( id int primary key, name varchar(20) ); create table student( id int primary key, name varchar(20), class_id int, foreign key(class_id) references classes(id) // 说明class_id必选是来之classes表中的id ); 数据库类别 关系型数据库: 类似于excel表 非关系型数据库: 类似键值对,k-v存储,存的是对象,可以扩展的对象 数据库不区分大小写 数据库中相关操作&#x3D;&#x3D;操作数据库&gt;操作数据库中的表&gt;表中的数据&#x3D;&#x3D; 操作数据库(show Drop Create Use)12345678910show databases CREATE DATABASE (IF NOT EXISTS) westosDROP DATABASE IF EXISTS westosUSE db03-- `可以使用让数据库名字不高亮,同时两个&quot;-&quot;是注释符use `db02` 操作数据库中的表数据类型 数据表的类型 &#x3D;&#x3D;实际&#x3D;&#x3D; 创建表 操作表中数据查询 去重distant","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://kuai-hua.github.io/categories/Mysql/"}],"tags":[]},{"title":"git的安装和学习过程","slug":"git学习笔记","date":"2022-11-09T02:43:04.000Z","updated":"2022-11-09T03:01:36.838Z","comments":true,"path":"2022/11/09/git学习笔记/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Git 的学习和使用(简介)Git（读音为&#x2F;gɪt&#x2F;）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper 。","text":"Git 的学习和使用(简介)Git（读音为&#x2F;gɪt&#x2F;）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper 。 &#x3D;&#x3D;Git Bash&#x3D;&#x3D; : Unix与Linux风格的命令行，使用最多，推荐最多Git CMD : Windows风格的命令行 Git GUI:图形界面的Git，不建议初学者使用，尽量先熟悉常用命令 1.常见的几种命令 基本的Linux命令学习1 ) 、cd:改变目录。2 ) 、cd ..回退到上一个目录，直接cd进入默认目录3 ) 、pwd :显示当前所在的目录路径。4 ) 、ls(Il):都是列出当前目录中的所有文件，只不过II(两个II)列出的内容更为详5 ) 、touch :新建一个文件如touch index.js 就会在当前目录下新建一个index.js文件。6 ) .rm:删除一个文件, rm index.js 就会把index.js文件删除。7 ) 、mkdir:新建一个目录,就是新建一个文件夹。8 ) .rm -r∶删除一个文件夹, rm -r src删除src目录rm -rf &#x2F;切勿在Linux中尝试!删除电脑中全部文件!9 ) 、mv移动文件, mv index.html src index.html是我们要移动的文件, src是目标文件夹标文件夹在同一目录下。10 ) 、reset重新初始化终端&#x2F;清屏。11 ) 、clear清屏。12 ) 、history查看命令历史。13 ) . help 帮助。14 ) 、exit退出。15 )、#表示注释 2.必须配置的东西 1234git -config --global user.name &quot;&quot; # 用户名字git -config --global user.email &quot;&quot; # 用户邮箱C:\\Users\\kuaihua\\.gitconfig写配置信息会在 3. 项目的工作区域 并且常用的三个命令:add,commit,push,clone&#x2F;fetch,checkout 4.搭建项目的两种方式:(克隆)第一种:git init 第二种:git clone [url] eg:https://gitee.com/enilu/web-flash.git 5.指令12345git status 查看文件的添加或者删除状态 git add . 添加所有文件到缓冲区git commit -m 提交缓冲区中的内容到本地仓库 -m 提交的介绍 6.上传忽略的东西(一般idea中会有) 7.生成公钥私钥1ssh-keygen -t rsa 然后就会在这个目录下生产两个文件 然后把pub后缀文件的公钥复制粘贴到图片的公钥处 8.简单做一下远程实验(创建一个项目) 9. idea中使用Git9.1 在git中新建一个文件 9.2克隆仓库到本地 9.3 在idea中创建一个springboot文件 这里的gitxuexi就是 9.4 把9.2中的文件复制到gitxuexi目录下,替换就行这是一种方法,简单 9.5然后登录git账号(可以省略,在terminal窗口中使用命令) &#x3D;&#x3D;如上面所示,这就完成了一次提交&#x3D;&#x3D; 10.分支","categories":[{"name":"git","slug":"git","permalink":"https://kuai-hua.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://kuai-hua.github.io/tags/git/"}]},{"title":"Swagger依赖跟相关使用笔记","slug":"Swagger","date":"2022-11-09T02:32:28.000Z","updated":"2022-11-09T03:58:13.761Z","comments":true,"path":"2022/11/09/Swagger/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/Swagger/","excerpt":"Swagger 学习官网 Spring boot集成Swagger123456789101112&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;","text":"Swagger 学习官网 Spring boot集成Swagger123456789101112&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 12# 解决springBoot版本与swagger版本冲突问题spring.mvc.pathmatch.matching-strategy=ant_path_matcher 1.2、Swagger 的Docket实例,可以很好的实现与前端的交互,辨别文件提交人123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configuration@EnableSwagger2 // 开启swagger2public class SwaggerConfig &#123; @Bean // 配置swagger的 Docket的 bean实例 public Docket docket(Environment environment)&#123; // 设置可以生效的环境,判断是否有需要的环境,返回一个布尔值,最后用Docket.enable(profiles)判断 Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;pro&quot;); boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(flag) .select() // RequestHandlerSelectors配置需要扫描包的方式 // basePackage 指定要扫描的包 [常用] // any 扫描全部 // none 都不扫描 // withClassAnnotation 扫描类上注解 // withMethodAnnotation 扫描方法上的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.kuaihua.controller&quot;)) // paths 过滤扫描路径,any,none,regex[正则],ant .paths(PathSelectors.ant(&quot;/kuaihua/**&quot;)) .build() ; &#125; private ApiInfo apiInfo()&#123; Contact contact = new Contact(&quot;kuaihua&quot;, &quot;https://www.bilibili.com/&quot;, &quot;2916126724@qq.com&quot;); return new ApiInfo(&quot;学习swagger&quot;, &quot;心有猛虎,细嗅蔷薇&quot;, &quot;1.0&quot;, &quot;urn:tos&quot;, contact, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); &#125;&#125; 如何让swagger在生产环境使用,在测试环境不适用xxxxxxxxxx61 1 2​3 4 5 org.apache.dubbo6 dubbo-spring-boot-starter7 2.7.38 9​10 11 12 com.github.sgroschupf13 zkclient14 0.115 16​17​18 19 20 21 org.apache.curator22 curator-framework23 2.12.024 25​26​27 28 29 org.apache.curator30 curator-recipes31 2.12.032 33​34 35 36 37 org.apache.zookeeper38 zookeeper39 3.4.1440 41 42 org.slf4j43 slf4j-log4j1244 45 46 47​48​49​50​51 52 org.springframework.boot53 spring-boot-starter-web54 55​56 57 org.springframework.boot58 spring-boot-starter-test59 test60 61 xml 12Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;pro&quot;);boolean flag = environment.acceptsProfiles(profiles); flag来判断它是否属于我想要的测试环境 通过.enable(true&#x2F;false) 来处理是否关闭Swagger的调试页面 关键.groupname(),这个可以很好的体现开发中的前后端链接作用12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SwaggerConfig &#123; @Bean public Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;A&quot;); &#125; @Bean public Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;B&quot;); &#125; @Bean public Docket docket3()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;C&quot;); &#125; @Bean public Docket docket4()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;D&quot;); &#125; @Bean // 配置swagger的 Docket的 bean实例 public Docket docket(Environment environment)&#123; // 设置可以生效的环境,判断是否有需要的环境,返回一个布尔值,最后用Docket.enable(profiles)判断 // Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;pro&quot;); // boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;kuaihua&quot;) // 这里是最重要的,只有设置了分组才可以协同开发 // 这里配置的是Docket的主要工作情况 .apiInfo(apiInfo()) // .enable(flag) .select() // RequestHandlerSelectors配置需要扫描包的方式 // basePackage 指定要扫描的包 [常用] // any 扫描全部 // none 都不扫描 // withClassAnnotation 扫描类上注解 // withMethodAnnotation 扫描方法上的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.kuaihua.controller&quot;)) // paths 过滤扫描路径,any,none,regex[正则],ant .paths(PathSelectors.ant(&quot;/kuaihua/**&quot;)) .build() ; &#125; 1234567891011121314151617package com.kuaihua.pojo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;// ApiModel ApiModelProperty 用来配合 Swagger的 Model 有中文注解@ApiModel(&quot;用户实体类&quot;)public class User &#123; @ApiModelProperty(&quot;用户名&quot;) public String name; @ApiModelProperty(&quot;密码&quot;) public String password;&#125;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kuai-hua.github.io/categories/SpringCloud/"}],"tags":[{"name":"Swagger","slug":"Swagger","permalink":"https://kuai-hua.github.io/tags/Swagger/"}]},{"title":"springcloud整合邮件异步","slug":"springcloud整合邮件异步","date":"2022-11-09T02:28:28.000Z","updated":"2022-11-09T03:57:58.136Z","comments":true,"path":"2022/11/09/springcloud整合邮件异步/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/springcloud%E6%95%B4%E5%90%88%E9%82%AE%E4%BB%B6%E5%BC%82%E6%AD%A5/","excerpt":"springboot整合邮件发送,异步任务与定时发送1.1 邮件发送依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;","text":"springboot整合邮件发送,异步任务与定时发送1.1 邮件发送依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 邮件发送的代码,可以自己适当的组装相关的邮件信息 12345678910111213141516171819202122232425262728293031323334@ResourceJavaMailSenderImpl mailSender;@Testvoid contextLoads() &#123; SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setSubject(&quot;给自己发一次邮件&quot;); mailMessage.setText(&quot;第一次给自己发邮件,有点紧张&quot;); mailMessage.setFrom(&quot;2916126724@qq.com&quot;); mailMessage.setTo(&quot;2916126724@qq.com&quot;); mailSender.send(mailMessage); System.out.println(&quot;发送成功&quot;);&#125;@Testvoid contextLoads2() throws MessagingException &#123; // 一个复杂的邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); // 组装邮件信息 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true); helper.setSubject(&quot;给自己发一次邮件,复杂的邮件&quot;); helper.setText(&quot;第一次给自己发复杂的邮件,有点紧张&quot;); // 这里使用绝对地址也可以 helper.addAttachment(&quot;1.png&quot;,new File(&quot;E:\\\\测试图片\\\\1.png&quot;)); helper.addAttachment(&quot;2.png&quot;,new File(&quot;E:\\\\测试图片\\\\1.png&quot;)); helper.setFrom(&quot;2916126724@qq.com&quot;); helper.setTo(&quot;2916126724@qq.com&quot;); mailSender.send(mimeMessage); System.out.println(&quot;发送成功&quot;);&#125; 1.2 异步任务 在main程序&#x3D;&#x3D;开启需要的需求代码&#x3D;&#x3D; 12345678910@SpringBootApplication@EnableAsync // 开启异步功能 ,与@Async协同使用@EnableScheduling // 开启定时执行任务功能 ,与@Schedule协使用public class Springboot09AsyncApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot09AsyncApplication.class, args); &#125;&#125; @EnableAsync // 在main入口中开启需要的功能 @Async // 表示这个任务可以异步进行 123456789103. 测试### 1.3 定时发送1. 在main开启需要的功能 ~~~java @EnableScheduling // 开启定时执行任务功能 ,与@Schedule协使用 @Scheduled // 格式:cron=&quot;秒 分 时 日 月 星期&quot; 测试 /** * 7月6日的5点4分1秒执行这个任务 * @Scheduled(cron = &quot;1 4 5 6 7 *&quot;) */ @Scheduled(cron = &quot;0 0 0 0 0 0&quot;) public void hello()&#123; System.out.println(&quot;hello,Schedule&quot;); &#125;","categories":[{"name":"springcloud","slug":"springcloud","permalink":"https://kuai-hua.github.io/categories/springcloud/"}],"tags":[]},{"title":"springboot常用的相关版本依赖","slug":"springboot常见依赖","date":"2022-11-09T01:45:14.000Z","updated":"2022-11-09T02:37:21.402Z","comments":true,"path":"2022/11/09/springboot常见依赖/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/springboot%E5%B8%B8%E8%A7%81%E4%BE%9D%E8%B5%96/","excerpt":"数据库12345678910111213&lt;!--Druid数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;","text":"数据库12345678910111213&lt;!--Druid数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; zookeeper+dubbo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!-- dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zookeeper客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--排除日志--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-framework --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--排除日志，不然会日志冲突,版本冲突,不排除会报错--&gt; &lt;!-- zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- springboot启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Mybatis123456&lt;!-- springboot整合mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Shiro授权认证 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Security安全,登录拦截 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot与theleaf整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- springboot与web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Thymeleaf与security整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok实体 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- springboot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.xmlunit&lt;/groupId&gt; &lt;artifactId&gt;xmlunit-core&lt;/artifactId&gt; &lt;version&gt;2.8.4&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt;","categories":[{"name":"springboot","slug":"springboot","permalink":"https://kuai-hua.github.io/categories/springboot/"}],"tags":[]},{"title":"application.yml常用配置各种组件在springboot的yml文件中的配置","slug":"application-yml常用配置","date":"2022-11-09T01:42:26.000Z","updated":"2022-11-09T01:44:32.563Z","comments":true,"path":"2022/11/09/application-yml常用配置/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/application-yml%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","excerpt":"application.yml文件配置123456789101112spring: datasource: username: root password: 888888 url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver# 整合mybatismybatis: type-aliases-package: com.kuaihua.pojo mapper-locations: classpath:mybatis/mapper/*.xml","text":"application.yml文件配置123456789101112spring: datasource: username: root password: 888888 url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver# 整合mybatismybatis: type-aliases-package: com.kuaihua.pojo mapper-locations: classpath:mybatis/mapper/*.xml 123456789101112131415161718192021222324252627282930spring: datasource: username: root password: 888888 url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #SpringBoot默认是不注入这些的，需要自己绑定 #druid数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat：监控统计、log4j：日志记录、wall：防御sql注入 #如果允许报错，java.lang.ClassNotFoundException: org.apache.Log4j.Properity #则导入log4j 依赖就行 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionoProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500","categories":[{"name":"springboot","slug":"springboot","permalink":"https://kuai-hua.github.io/categories/springboot/"}],"tags":[]},{"title":"Theleaf与springboot整合,在html中的使用","slug":"Theleaf","date":"2022-11-09T01:09:41.000Z","updated":"2022-11-09T01:39:34.793Z","comments":true,"path":"2022/11/09/Theleaf/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/Theleaf/","excerpt":"Thymeleaf的使用规则 在开头常见的需要引入相关的链接xmlns:th=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot; 12345678910&lt;html class=&quot;no-js&quot; lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:th=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt; xmlns:th=&quot;http://www.thymeleaf.org&quot;xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot; xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&gt;","text":"Thymeleaf的使用规则 在开头常见的需要引入相关的链接xmlns:th=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot; 12345678910&lt;html class=&quot;no-js&quot; lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:th=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt; xmlns:th=&quot;http://www.thymeleaf.org&quot;xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot; xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&gt; 表达语法 123456简单表达式：变量表达式： $ &#123;...&#125;选择变量表达式： \\* &#123;...&#125;消息表达式： ＃ &#123;...&#125;，国际化要用链接⽹址表达式： @ &#123;...&#125; 本地连接，src，link，href⽚段表达式： 〜&#123;...&#125; 依赖springBoot导入的依赖 12345678910111213141516171819202122&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-thymeleaf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; Theleaf整合1.1提取和使用文件公共部分 文件提取代码th:fragment=&quot;topside&quot; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;!--顶部导航栏提取 th:fragment=&quot;topside&quot;--&gt;&lt;nav class=&quot;navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0&quot; == th:fragment=&quot;topside&quot;==&gt; &lt;a class=&quot;navbar-brand col-sm-3 col-md-2 mr-0&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;[[$&#123;session.LoginUser&#125;]]&lt;/a&gt; &lt;input class=&quot;form-control form-control-dark w-100&quot; type=&quot;text&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt; &lt;ul class=&quot;navbar-nav px-3&quot;&gt; &lt;li class=&quot;nav-item text-nowrap&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;Sign out&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; &lt;!--侧边导航栏 th:fragment=&quot;sidebar&quot; --&gt;&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; th:fragment=&quot;sidebar&quot;&gt; &lt;div class=&quot;sidebar-sticky&quot;&gt; &lt;h6 class=&quot;sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted&quot;&gt; &lt;span&gt;Saved reports&lt;/span&gt; &lt;a class=&quot;d-flex align-items-center text-muted&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-plus-circle&quot;&gt;&lt;circle cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;10&quot;&gt;&lt;/circle&gt;&lt;line x1=&quot;12&quot; y1=&quot;8&quot; x2=&quot;12&quot; y2=&quot;16&quot;&gt;&lt;/line&gt;&lt;line x1=&quot;8&quot; y1=&quot;12&quot; x2=&quot;16&quot; y2=&quot;12&quot;&gt;&lt;/line&gt;&lt;/svg&gt; &lt;/a&gt; &lt;/h6&gt; &lt;/div&gt;&lt;/nav&gt;&lt;/html&gt; 提取 代码的使用 第一个commons是文件夹,第二个是commons是html 1234567&lt;!--顶栏--&gt;&lt;div th:replace=&quot;~&#123;commons/commons::topside&#125;&quot;&gt;&lt;/div&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--侧边栏--&gt; &lt;div th:replace=&quot;~&#123;commons/commons::sidebar(active=&#x27;main.html&#x27;)&#125;&quot;&gt;&lt;/div&gt; 1.2 theleaf对列表内容进行循环导出123456789101112131415161718@Controllerpublic class UserController &#123; @Autowired UserServiceImpl userService; @RequestMapping(&quot;/allUser&quot;) public String getAllUser(Model model)&#123; Collection&lt;User&gt; users = userService.queryAllUser(); model.addAttribute(&quot;users&quot;,users); System.out.println(users); return &quot;emp/list&quot;; &#125;&#125; 123456789101112131415161718192021222324&lt;tbody&gt; &lt;!--/*@thymesVar id=&quot;emps&quot; type=&quot;List&quot;*/--&gt; &lt;tr th:each=&quot;user:$&#123;users&#125;&quot;&gt; &lt;!--/*@thymesVar id=&quot;getId&quot; type=&quot;Class50&quot;*/--&gt; &lt;td th:text=&quot;$&#123;user.getId()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getUserCode()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getUserName()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getUserPassword()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getGender()==1?&#x27;女&#x27;:&#x27;男&#x27;&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;#dates.format(user.getBirthday(),&#x27;yyyy-MM-dd&#x27;)&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getPhone()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getAddress()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getUserRole()==1?&#x27;管理员&#x27;:&#x27;用户&#x27;&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getCreatedBy()==1?&#x27;管理员&#x27;:&#x27;用户&#x27;&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;#dates.format(user.getCreationDate(),&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.getModifyBy()==1?&#x27;管理员&#x27;:&#x27;用户&#x27;&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;#dates.format(user.getModifyDate(),&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/td&gt; &lt;!--&lt;td th:text=&quot;$&#123;emp.department.getDepartmentName()&#125;&quot;&gt;&lt;/td&gt;--&gt; &lt;!--&lt;td th:text=&quot;$&#123;#dates.format(emp.getBirth(), &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/td&gt;--&gt; &lt;td&gt; &lt;a type=&quot;submit&quot; class=&quot;btn btn-sm btn-primary&quot; th:href=&quot;@&#123;#&#125;&quot;&gt;编辑&lt;/a&gt; &lt;a type=&quot;submit&quot; class=&quot;btn btn-sm btn-danger&quot;th:href=&quot;@&#123;#&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; 结果展示 1.3 利用theleaf完成点谁谁高亮原理,利用replace传参 1&lt;div th:replace=&quot;~&#123;commons/commons::sidebar(active=&#x27;list.html&#x27;)&#125;&quot;&gt;&lt;/div&gt; 1&lt;div th:replace=&quot;~&#123;commons/commons::sidebar(active=&#x27;main.html&#x27;)&#125;&quot;&gt;&lt;/div&gt; 公共页面代码${active&#x3D;&#x3D;’main.html’? ‘nav-link active’:’nav-link’}和${active&#x3D;&#x3D;’list.html’?’nav-link active’:’nav-link’} 123456&lt;a th:class=&quot;$&#123;active==&#x27;main.html&#x27;? &#x27;nav-link active&#x27;:&#x27;nav-link&#x27;&#125;&quot; th:href=&quot;@&#123;/index&#125;&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-home&quot;&gt; &lt;path d=&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;9 22 9 12 15 12 15 22&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; 首页 1234567891011&lt;li class=&quot;nav-item&quot;&gt; &lt;a th:class=&quot;$&#123;active==&#x27;list.html&#x27;?&#x27;nav-link active&#x27;:&#x27;nav-link&#x27;&#125;&quot; th:href=&quot;@&#123;/allUser&#125;&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-users&quot;&gt; &lt;path d=&quot;M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2&quot;&gt;&lt;/path&gt; &lt;circle cx=&quot;9&quot; cy=&quot;7&quot; r=&quot;4&quot;&gt;&lt;/circle&gt; &lt;path d=&quot;M23 21v-2a4 4 0 0 0-3-3.87&quot;&gt;&lt;/path&gt; &lt;path d=&quot;M16 3.13a4 4 0 0 1 0 7.75&quot;&gt;&lt;/path&gt; &lt;/svg&gt; 用户管理 &lt;/a&gt;&lt;/li&gt; Theleaf时间格式转换1. 时间格式转换,#dates.format#dates.format(time,&#39;yyyy/MM/dd HH:mm:ss&#39;) 2. theleaf中使用三目运算符,并且不能修改readonlyNullPointerException判断是否为空指针, 1&lt;input th:value=&quot;$&#123;user.getCreationDate()==NullPointerException?#dates.format(time,&#x27;yyyy/MM/dd HH:mm:ss&#x27;):#dates.format(user.getCreationDate(),&#x27;yyyy/MM/dd HH:mm:ss&#x27;)&#125;&quot; type=&quot;text&quot; name=&quot;creationDate&quot;class=&quot;form-control&quot; placeholder=&quot;2011/11/12&quot; readonly&gt; 3. 获取当前时间#dates.createNow()1&lt;input th:value=&quot;$&#123;#dates.format(#dates.createNow(),&#x27;yyyy/MM/dd HH:mm:ss&#x27;)&#125;&quot; type=&quot;text&quot; name=&quot;modifyDate&quot; class=&quot;form-control&quot; placeholder=&quot;2000/1/1&quot;&gt; 4. 选择项,管理员对应的是数据库中的1123456789101112131415&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;创建者&lt;/label&gt;&lt;br&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input th:checked=&quot;$&#123;user.getUserRole()==1&#125;&quot; class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;createdBy&quot; value=&quot;1&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;管理员&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input th:checked=&quot;$&#123;user.getUserRole()==2&#125;&quot; class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;createdBy&quot; value=&quot;2&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;会员&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input th:checked=&quot;$&#123;user.getUserRole()==3&#125;&quot; class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;createdBy&quot; value=&quot;3&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;用户&lt;/label&gt; &lt;/div&gt;&lt;/div&gt; 这就是结果","categories":[{"name":"springboot","slug":"springboot","permalink":"https://kuai-hua.github.io/categories/springboot/"}],"tags":[]},{"title":"JSR303注解的简单使用","slug":"JSR303","date":"2022-11-09T01:06:45.000Z","updated":"2022-11-09T01:38:16.633Z","comments":true,"path":"2022/11/09/JSR303/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/JSR303/","excerpt":"JSR303中含有的注解","text":"JSR303中含有的注解 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须 大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max&#x3D;, min&#x3D;) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex&#x3D;,flag&#x3D;) 被注释的元素必须符合指定的正则表达式 @NotBlank(message &#x3D;) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min&#x3D;,max&#x3D;) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min&#x3D;,max&#x3D;,message&#x3D;) 被注释的元素必须在合适的范围内 相关依赖12345// 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt;","categories":[{"name":"springboot","slug":"springboot","permalink":"https://kuai-hua.github.io/categories/springboot/"}],"tags":[]},{"title":"shiro授权认证与thyleaf的简单使用","slug":"shiro","date":"2022-11-09T01:04:40.000Z","updated":"2022-11-09T01:39:40.204Z","comments":true,"path":"2022/11/09/shiro/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/shiro/","excerpt":"1、shiro的学习和使用1.1、三大对象 Subject SecurityMassager 1234567Subject currentUser = SecurityUtil.getSubject(); 获得SubjectSession session = currentUser.getSession(); 通过Subject 获取 sessionif（！currentUser.isAuthenticated()）; 判断用户是否被认证currentUser.getPrincipal(); 回顾当前用户的认证currentUser.hasRole(&quot;schwartz&quot;) 获得用户是否拥有schwartz这个角色currentUser.isPermitted(&quot;lighsaber.wield&quot;); 获得用户后面的参数currentUser.logout(); 注销 xxxxxxxxxx61 1 2​3 4 5 org.apache.dubbo6 dubbo-spring-boot-starter7 2.7.38 9​10 11 12 com.github.sgroschupf13 zkclient14 0.115 16​17​18 19 20 21 org.apache.curator22 curator-framework23 2.12.024 25​26​27 28 29 org.apache.curator30 curator-recipes31 2.12.032 33​34 35 36 37 org.apache.zookeeper38 zookeeper39 3.4.1440 41 42 org.slf4j43 slf4j-log4j1244 45 46 47​48​49​50​51 52 org.springframework.boot53 spring-boot-starter-web54 55​56 57 org.springframework.boot58 spring-boot-starter-test59 test60 61 xml Realm","text":"1、shiro的学习和使用1.1、三大对象 Subject SecurityMassager 1234567Subject currentUser = SecurityUtil.getSubject(); 获得SubjectSession session = currentUser.getSession(); 通过Subject 获取 sessionif（！currentUser.isAuthenticated()）; 判断用户是否被认证currentUser.getPrincipal(); 回顾当前用户的认证currentUser.hasRole(&quot;schwartz&quot;) 获得用户是否拥有schwartz这个角色currentUser.isPermitted(&quot;lighsaber.wield&quot;); 获得用户后面的参数currentUser.logout(); 注销 xxxxxxxxxx61 1 2​3 4 5 org.apache.dubbo6 dubbo-spring-boot-starter7 2.7.38 9​10 11 12 com.github.sgroschupf13 zkclient14 0.115 16​17​18 19 20 21 org.apache.curator22 curator-framework23 2.12.024 25​26​27 28 29 org.apache.curator30 curator-recipes31 2.12.032 33​34 35 36 37 org.apache.zookeeper38 zookeeper39 3.4.1440 41 42 org.slf4j43 slf4j-log4j1244 45 46 47​48​49​50​51 52 org.springframework.boot53 spring-boot-starter-web54 55​56 57 org.springframework.boot58 spring-boot-starter-test59 test60 61 xml Realm 1.2、用到的依赖有 12345678&lt;!-- https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro --&gt; &lt;!--整合Thymeleaf--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; 1.3、学习的案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.kuaihua.config;import com.kuaihua.pojo.User;import com.kuaihua.service.UserService;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.session.Session;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.Subject;import org.springframework.beans.factory.annotation.Autowired;public class UserRealm extends AuthorizingRealm &#123; @Autowired UserService userService; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行了 授权 doGetAuthorizationInfo==========&quot;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); // info.addStringPermission(&quot;user:add&quot;); //拿到当前用户 Subject subject = SecurityUtils.getSubject(); User currentUser = (User) subject.getPrincipal(); // 拿到当前用户信息，这是下面的认证方法new SimpleAuthenticationInfo(user,user.getPwd(),&quot;&quot;)中的user参数 info.addStringPermission(currentUser.getPerms()); // 从当前用户中获取到需要的权限perms参数 return info; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;执行了 认证 doGetAuthenticationInfo==========&quot;); // // 这就是认证，本来是从数据库中取得数据，但是这里先模拟数据 // String name = &quot;root&quot;; // String password = &quot;123456&quot;; // // UsernamePasswordToken userToken = (UsernamePasswordToken) token; // if(!userToken.getUsername().equals(name))&#123; // return null; // return null 的意思是抛出异常 // &#125; // //认证密码，shiro帮我们做了，不用我们做，保证数据的安全性 // return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;); // &#125; // // 这就是认证，本来是从数据库中取得数据，但是这里先模拟数据 // 从数据库中获取数据 UsernamePasswordToken userToken = (UsernamePasswordToken) token; User user = userService.queryUserByName(userToken.getUsername()); if (user == null)&#123; return null; &#125; Subject currentSubject = SecurityUtils.getSubject(); Session session = currentSubject.getSession(); session.setAttribute(&quot;loginUser&quot;,user); // 这里使用session存值，然后再index.html中判断loginUser是有值，如果有就说明有人登录，没有就是没人登录 //认证密码，shiro帮我们做了，不用我们做，保证数据的安全性=,这里的user需要与上面的授权方法联动，getPrincipal return new SimpleAuthenticationInfo(user,user.getPwd(),&quot;&quot;); &#125;&#125; 下面的步骤2跟步骤3是死代码，第四个类也是死代码，需要跟Thymeleaf联动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import at.pollux.thymeleaf.shiro.dialect.ShiroDialect;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.LinkedHashMap;import java.util.Map;@Configurationpublic class ShiroConfig&#123; // ShiroFilterFactoryBean 步骤3 @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); bean.setSecurityManager(defaultWebSecurityManager); /* * anon : 无需认证就可以访问 * authc : 必须认证才可以访问 * user ： 必须拥有记住我功能后才可以使用 * perms ： 必须拥有对某个资源的权限才可以使用 * roles ： 拥有某个角色权限才可以使用 * */ // 拦截 Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); // filterMap.put(&quot;/user/add&quot;,&quot;anon&quot;); // filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;); // 正常情况下，未授权的页面会跳到授权的页面中 filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;); filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;); bean.setFilterChainDefinitionMap(filterMap); bean.setLoginUrl(&quot;/toLogin&quot;); bean.setUnauthorizedUrl(&quot;/unAuth&quot;); return bean; &#125; // defaultWebSecurityManager 步骤2 @Bean(name = &quot;securityManager&quot;) public DefaultWebSecurityManager defaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); return securityManager; &#125; // Realm 步骤1，由下往上写，不走都是确定的，不用记，做好笔记就行，一般记不住 @Bean(name = &quot;userRealm&quot;) public UserRealm userRealm()&#123; return new UserRealm(); &#125; // ShiroDialect,用来整合shiro跟Thymeleaf，死代码，需要跟Thymeleaf联动 @Bean public ShiroDialect shiroDialect()&#123; return new ShiroDialect(); &#125;&#125; 1.4、html中代码案例12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;首页&lt;/p&gt;&lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/h1&gt;&lt;!--&lt;div th:if=&quot;session.loginUser==null&quot;&gt;--&gt;&lt;div shiro:notAuthenticated&gt; &lt;a th:href=&quot;@&#123;/toLogin&#125;&quot;&gt; 登录&lt;/a&gt;&lt;/div&gt;&lt;hr&gt;&lt;div shiro:hasPermission=&quot;user:add&quot;&gt; &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;添加&lt;/a&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt; &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;修改&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"springboot","slug":"springboot","permalink":"https://kuai-hua.github.io/categories/springboot/"}],"tags":[]},{"title":"Druid数据源springboot相关依赖与配置","slug":"Druid","date":"2022-11-09T00:36:51.000Z","updated":"2022-11-09T03:56:50.069Z","comments":true,"path":"2022/11/09/Druid/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/Druid/","excerpt":"依赖123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt;","text":"依赖123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt; xxxxxxxxxx30 1spring:2 datasource:3 username: root4 password: 8888885 url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai6 driver-class-name: com.mysql.cj.jdbc.Driver7 type: com.alibaba.druid.pool.DruidDataSource8​9​10 #SpringBoot默认是不注入这些的，需要自己绑定11 #druid数据源专有配置12 initialSize: 513 minIdle: 514 maxActive: 2015 maxWait: 6000016 timeBetweenEvictionRunsMillis: 6000017 minEvictableIdleTimeMillis: 30000018 validationQuery: SELECT 1 FROM DUAL19 testWhileIdle: true20 testOnBorrow: false21 testOnReturn: false22 poolPreparedStatements: true23​24 #配置监控统计拦截的filters，stat：监控统计、log4j：日志记录、wall：防御sql注入25 #如果允许报错，java.lang.ClassNotFoundException: org.apache.Log4j.Properity26 #则导入log4j 依赖就行27 filters: stat,wall,log4j28 maxPoolPreparedStatementPerConnectionSize: 2029 useGlobalDataSourceStat: true30 connectionoProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500yml123456789101112131415161718192021222324252627282930spring: datasource: username: root password: 888888 url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # Druid数据源 #SpringBoot默认是不注入这些的，需要自己绑定 #druid数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat：监控统计、log4j：日志记录、wall：防御sql注入 #如果允许报错，java.lang.ClassNotFoundException: org.apache.Log4j.Properity #则导入log4j 依赖就行 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionoProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500","categories":[{"name":"springboot","slug":"springboot","permalink":"https://kuai-hua.github.io/categories/springboot/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://kuai-hua.github.io/tags/mysql/"}]},{"title":"Ajax","slug":"Ajax","date":"2022-11-09T00:33:12.000Z","updated":"2022-11-09T01:41:15.985Z","comments":true,"path":"2022/11/09/Ajax/","link":"","permalink":"https://kuai-hua.github.io/2022/11/09/Ajax/","excerpt":"Ajax：把页面是否跳转的决定权交给了前段AJAX &#x3D; Asynchronous JavaScript and XML. AJAX 是一种用于创建快速动态网页的技术。","text":"Ajax：把页面是否跳转的决定权交给了前段AJAX &#x3D; Asynchronous JavaScript and XML. AJAX 是一种用于创建快速动态网页的技术。 AJAX 通过在后台与服务器进行少量数据交换，使网页实现异步更新。这意味着可以在不重载整个页面的情况下，对网页的某些部分进行更新。 下面是Ajax的固定语法，但是必要的只有二个$.ajax({ ​ url: ‘’, ​ type: ‘post’, ​ data : {‘name’: ‘sgt’, ‘pwd’: ‘123’}, ，这里的数据就是需要携带回去给后台判断的参数 ​ ​ success:function (data) { ​ swal({ ​ title: ‘AJAX’, ​ text: ‘模拟这里显示了返回的数据’, ​ icon: ‘success’, ​ button: ‘OK’, }) 必要的三个12345678910111213$.ajax(&#123; url: &#x27;&#x27;, &#123;#不写默认朝当前页面发请求#&#125; type: &#x27;post&#x27;, &#123;#请求方式#&#125; data : &#123;&#x27;name&#x27;: &#x27;sgt&#x27;, &#x27;pwd&#x27;: &#x27;123&#x27;&#125;, &#123;#发送的请求数据#&#125; &#123;#这里的data就是回调函数success获取到的后端响应返回的数据#&#125; 回调函数：就是要发挥的数据(个人理解)&#125;） 或者 1234567891011$.post(&#123; url: &#x27;&#x27;&#123;#不写默认朝当前页面发请求#&#125;&quot; data : &#123;&#x27;name&#x27;: &#x27;sgt&#x27;, &#x27;pwd&#x27;: &#x27;123&#x27;&#125;, &#123;#发送的请求数据#&#125;，这里可以默认为空 &#123;#这里的data就是回调函数success获取到的后端响应返回的数据#&#125;&#125;) 总结1使用jQuery就导jQUery，使用Vue就导入Vue，两个都用，自己原生态实现 使用Ajax三部曲：1.编写对应的Controller，返回消息或字符串或者json格式数据；2.编写ajax请求1.url:controller请求2.data：键值对，可以不定义undefined3.success：回调函数 3.给Ajax绑定事件，点击.click，失去焦点onblur，键盘弹起keyup下面是一个ajax案例1234567891011121314151617@RestControllerpublic class AjaxController &#123; @RequestMapping(&quot;/t2&quot;) public List&lt;User&gt; test2()&#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(1,&quot;kuaihua&quot;,&quot;123456&quot;)); userList.add(new User(2,&quot;kuaihua1&quot;,&quot;1234516&quot;)); userList.add(new User(3,&quot;kuaihua2&quot;,&quot;1234536&quot;)); userList.add(new User(4,&quot;kuaihua3&quot;,&quot;1234563&quot;)); return userList; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536 &lt;script&gt; $(function ()&#123; $(&quot;#btn&quot;).click(function () &#123; // 这里的function(data)代表的数据就是t2中返回的userList数据 $.post(&quot;$&#123;pageContext.request.contextPath&#125;/t2&quot;,function(data) &#123; console.log(data) var html = &quot;&quot;; for (let i = 0; i &lt; data.length; i++) &#123; html +=&quot;&lt;tr&gt;&quot;+ &quot;&lt;td&gt;&quot; +data[i].id+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot; +data[i].name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot; +data[i].password+&quot;&lt;/td&gt;&quot;+ &quot;&lt;/tr&gt;&quot; &#125; $(&quot;#context&quot;).html(html); &#125;) &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;加载数据&quot; id=&quot;btn&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=&quot;context&quot;&gt; &lt;%-- 这里就显得很空--%&gt; &lt;%-- 这里显示从后台加载的数据--%&gt; &lt;/tbody&gt; &lt;/table&gt;","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://kuai-hua.github.io/categories/Ajax/"}],"tags":[]},{"title":"Linux相关笔记","slug":"Linux","date":"2022-11-08T13:37:13.000Z","updated":"2022-11-09T02:37:24.912Z","comments":true,"path":"2022/11/08/Linux/","link":"","permalink":"https://kuai-hua.github.io/2022/11/08/Linux/","excerpt":"Linux学习常用命令:(一般都是命令的组合使用)12345678910111213ls : 列出目录-a 所有文件,包括隐藏文件,]-l 文件目录,不包括隐藏文件ls ll 查看文件ls -al 查看全部的文件(包括隐藏)以及目录跟用法 (all)pwd 显示当前用户所在目录mkdir -p /test/test1/test2/test3 单次创建多层级目录rmdir test 删除test目录cp 需要拷贝的文件名 需要拷贝到的地方 cp拷贝文件rm -rf test.sh 删除test.sh文件","text":"Linux学习常用命令:(一般都是命令的组合使用)12345678910111213ls : 列出目录-a 所有文件,包括隐藏文件,]-l 文件目录,不包括隐藏文件ls ll 查看文件ls -al 查看全部的文件(包括隐藏)以及目录跟用法 (all)pwd 显示当前用户所在目录mkdir -p /test/test1/test2/test3 单次创建多层级目录rmdir test 删除test目录cp 需要拷贝的文件名 需要拷贝到的地方 cp拷贝文件rm -rf test.sh 删除test.sh文件 以下是对这些目录的解释： &#x2F;bin： bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 &#x2F;boot：&#x3D;&#x3D;这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。&#x3D;&#x3D; &#x2F;dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 &#x2F;etc：&#x3D;&#x3D;etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。&#x3D;&#x3D; &#x2F;home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 &#x2F;lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 xxxxxxxxxx31 12&lt;html lang&#x3D;”en” xmlns:th&#x3D;”http://www.thymeleaf.org&quot; 3 xmlns:shiro&#x3D;”http://www.pollix.at/thymeleaf/shiro&quot;&gt;45 6 Title789​10首页11121314 登录151617​18​1920​21 添加22​2324​2526 修改2728​29​3031html &#x2F;media： linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 &#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。 &#x2F;opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 &#x2F;proc：proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： 1echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all &#x2F;root：&#x3D;&#x3D;该目录为系统管理员，也称作超级权限者的用户主目录。&#x3D;&#x3D; &#x2F;sbin： s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 &#x2F;selinux： 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 &#x2F;srv： 该目录存放一些服务启动之后需要提取的数据。 &#x2F;sys： 这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。 sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。 该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 &#x2F;tmp： tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 &#x2F;usr：&#x3D;&#x3D;usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录&#x3D;&#x3D; &#x2F;usr&#x2F;bin：系统用户使用的应用程序。 &#x2F;usr&#x2F;sbin：超级用户使用的比较高级的管理程序和系统守护程序。 &#x2F;usr&#x2F;src：内核源代码默认的放置目录。 &#x2F;var： &#x3D;&#x3D;var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。&#x3D;&#x3D; &#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。 文件内容查看 硬链接和软连接 添加用户 12-l 创建用户组 环境安装rpm安装jdk安装 环境变量配置/etc/profile12345JAVA_HOME=/usr/java/jdk1.8.0_202-amd64CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib PATH=$JAVA_HOME/bin:$PATH:$JAVA_HOME/jre/libexport PATH CLASSPATH JAVA_HOME 1soure /etc/profile # 使一个目录生效 查看端口是否开启 开启防火墙端口 重启防火墙 解压缩安装 解压 1tar -zxvf apache-tomcat-9.0.43.tar.gz 启动tomcat测试 .&#x2F;xxx.sh 脚本就可以运行了(绿色是可以执行的,红色是不可以执行的) 12./startup.sh # 开启tomcat./shutdown.sh # 关闭tomcat 关于8080端口 1234[root@kuaihua linux]# lsapache-tomcat-9.0.43.tar.gz jdk-8u202-linux-x64.rpm 公共 环境 模板 视频 图片 文档 下载 音乐 桌面[root@kuaihua linux]# tar -zxvf apache-tomcat-9.0.43.tar.gz # 解压文件 解压过后就会多一个蓝色的apache-tomcat-9.0.43 文件夹 开启防火墙 1234567891、开启防火墙 systemctl start firewalld2、开放指定端口 firewall-cmd --zone=public --add-port=1935/tcp --permanent3、重启后才可以看到开放端口 systemctl restart firewalld.servicefirewall-cmd --list-ports 在线安装(yum安装)Dockerl安装 1234567891011121314151617181920212223242526272829303132yum -y install gcc 安装gccyum -y install gcc-c++ 安装gcc-c++yum remove docker / 卸载以前的docker版本 docker-client / docker-client-latest / docker-common / docker-latest / docker-latest-logrotate / docker-logrotate / docker-engineyum install -y yum-utils / device-mapper-persistent-data / lvm2 yum-config-manager / --add-repo / http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.rep yum -y install docker-ce docker-ce-cli containerd.io docker-compose-pluginsystemctl start docker 开启dockerps -ef|grep docker # 查看docker进程docker run hello-world # docker跑hello-world程序,没有就从官网拉去 123456789[root@localhost ~]# docker run hello-world # 跑hello-worldUnable to find image &#x27;hello-world:latest&#x27; locallylatest: Pulling from library/hello-world2db29710123e: Pull complete Digest: sha256:62af9efd515a25f84961b70f973a798d2eca956b1b2b026d0a4a63a3b0b6a3f2Status: Downloaded newer image for hello-world:latestHello from Docker! rpm卸载","categories":[{"name":"Linux","slug":"Linux","permalink":"https://kuai-hua.github.io/categories/Linux/"}],"tags":[]},{"title":"zookeeper+dubbo版本跟依赖","slug":"zookeeper-dubbo版本跟依赖","date":"2022-11-08T13:18:29.000Z","updated":"2022-11-08T13:27:04.184Z","comments":true,"path":"2022/11/08/zookeeper-dubbo版本跟依赖/","link":"","permalink":"https://kuai-hua.github.io/2022/11/08/zookeeper-dubbo%E7%89%88%E6%9C%AC%E8%B7%9F%E4%BE%9D%E8%B5%96/","excerpt":"zookeeper版本(3.4.14)","text":"zookeeper版本(3.4.14) 版本依赖(版本不同会出现很多错误,原因不知道) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--排除日志--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-framework --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--排除日志，不然会日志冲突--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;","categories":[{"name":"springboot","slug":"springboot","permalink":"https://kuai-hua.github.io/categories/springboot/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://kuai-hua.github.io/tags/zookeeper/"},{"name":"dubbo","slug":"dubbo","permalink":"https://kuai-hua.github.io/tags/dubbo/"}]},{"title":"修改hexo的next(8.12.1)主题的页面加载,评论设置","slug":"简单修改hexo的相关设置","date":"2022-11-08T12:04:59.000Z","updated":"2022-11-10T13:17:19.773Z","comments":true,"path":"2022/11/08/简单修改hexo的相关设置/","link":"","permalink":"https://kuai-hua.github.io/2022/11/08/%E7%AE%80%E5%8D%95%E4%BF%AE%E6%94%B9hexo%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/","excerpt":"相关版本信息","text":"相关版本信息 修改页面加载动画1主题的_config.yml搜索pace修改里面的样式就行 参考优化参考主题优化 Valine的评论设置Leancloud注册登录网址 注册参考网址 1234567891011121314151617181920212223242526leancloud_visitors: enable: true app_id: 5FvLcxvoP7bZCapbl8eSk61f-gzGzoHsz # &lt;your app id&gt;你自己的leancloud appid app_key: bJTS0ZxmmgU96djhQc4whBd # &lt;your app key&gt; # Required for apps from CN region server_url: https://5fvlcxvo.lc-cn-n1-shared.com # &lt;your server url&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&#x27;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: truevaline: enable: true appId: 5FvLcxvoP7bZCapbl8eSk61f-gzGzoHsz #你的leancloud里面的AppID appKey: bJTS0ZxmmgU96djhQc4whBd #你的leancloud里面的AppKey placeholder: 期待你的评论 # Comment box placeholder avatar: mm # gravatar style meta: [nick, mail, link] # Custom comment header pageSize: 10 # pagination size lang: zh-cn # Language, available values: en, zh-cn visitor: false #文章阅读量统计 comment_count: false # If false, comment count will only be displayed in post page, not in home page 评论计数 serverURLs: #REST API服务器地址 https://。。。。 # 这里必须写,不然评论提交不了,rest api也是在leancloud安全设置中看, recordIP: false # Whether to record the commenter IP enableQQ: true requiredFields: [nick, mail] # Set required fields: [nick] | [nick, mail] 要求写评论必须要写昵称和邮箱,啥都不加,或者写[nick] 隐藏底部的驱动提供之类的12# Powered by Hexo &amp; NexT powered: false # true变成false 修改内嵌链接样式css颜色选择 在next中的index.styl文件添加一下信息 1234567.post-body p a&#123; color: #0000FF; # 蓝色 border-bottom: none; # 下划线 &amp;:hover&#123; color: #FF0000; # 红色 &#125;&#125;","categories":[{"name":"hexo","slug":"hexo","permalink":"https://kuai-hua.github.io/categories/hexo/"}],"tags":[]},{"title":"hexo的next(8.12.1)主题图片不能显示","slug":"hexo的next主题图片不能显示","date":"2022-11-08T04:40:13.000Z","updated":"2022-11-09T02:37:27.023Z","comments":true,"path":"2022/11/08/hexo的next主题图片不能显示/","link":"","permalink":"https://kuai-hua.github.io/2022/11/08/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E5%9B%BE%E7%89%87%E4%B8%8D%E8%83%BD%E6%98%BE%E7%A4%BA/","excerpt":"版本信息","text":"版本信息 安装依赖跟修改相关文件1231. 安装依赖包 npm install hexo-asset-image -- save2. 在hexo根目录的_config.yml设置post_asset_folder: true # 作用利用&quot;hexo n &#x27;文件名&#x27;&quot;生成一个新md文件的同时,生成一 个在 source/_posts目录下生成一个同名的文件夹,这个文件夹就是用来放置需要保存的图片的3. 引入图片,格式是(./我的博客搭建-过程/eg01.png),必须是反斜杠,不然还是不会显示出来,而且要写相对路径,绝对路径在我这里不可以显示&gt;_&lt;","categories":[{"name":"hexo","slug":"hexo","permalink":"https://kuai-hua.github.io/categories/hexo/"}],"tags":[]},{"title":"博客的简单使用笔记","slug":"博客的简单使用","date":"2022-11-06T04:19:47.000Z","updated":"2022-11-09T04:03:23.802Z","comments":true,"path":"2022/11/06/博客的简单使用/","link":"","permalink":"https://kuai-hua.github.io/2022/11/06/%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"搭建参考网址参考网址 1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy # 常用的命令,在git窗口发布到博客上(清理,生成静态文件,发布)","text":"搭建参考网址参考网址 1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy # 常用的命令,在git窗口发布到博客上(清理,生成静态文件,发布) 创建一个新的文件1hexo new &quot;测试&quot; 生成静态文件1hexo g 打开localhost:4000网址1hexo s 补齐缺失模块1npm i hexo-generator-json-content --save 分类跟标签创建和使用 文章发布12345678910111213命名结束完成后，在/source/_posts文件内鼠标右键点击空白处，选择Git Bash Here：输入 hexo g (完整命令为hexo generate)，用于生成静态文件；然后输入 hexo s(完整命令为hexo server)，用于启动服务器，主要用来本地预览；完成后 打开浏览器输入 http://localhost:4000，会发现多了你刚写的那篇博客;最后输入hexo d(hexo deploy)，用于将本地文件发布到github等git仓库上；文章发布完成注意：每次对hexo博客上的博客.md文件进行更改后都要重复以上步骤，这样更改的内容才能在hexo博客上显示。 hexo generate &amp;&amp; hexo deploy (一般写这个就行) 显示图片 1234- 安装依赖包 npm install hexo-asset-image -- save- 在hexo根目录的_config.yml设置post_asset_folder: true # 作用是在生成一个新md文件的同时,生成一个在source/_posts目录下生成一个同名的文件夹,这个文件夹就是用来放置需要保存的图片的- 引入图片,格式类是(./我的博客搭建-过程/image-20221107091956291.png),必须是反斜杠,不然还是不会显示出来","categories":[{"name":"hexo","slug":"hexo","permalink":"https://kuai-hua.github.io/categories/hexo/"}],"tags":[]},{"title":"Hello,Hexo","slug":"hello-world","date":"2022-11-05T02:47:35.673Z","updated":"2022-11-09T13:14:07.017Z","comments":true,"path":"2022/11/05/hello-world/","link":"","permalink":"https://kuai-hua.github.io/2022/11/05/hello-world/","excerpt":"快速入门新建一篇文章1$ hexo new &quot;My New Post&quot;","text":"快速入门新建一篇文章1$ hexo new &quot;My New Post&quot; 运行服务1$ hexo server 生成静态文件1$ hexo generate 部署到远程站点1$ hexo deploy","categories":[],"tags":[]}],"categories":[{"name":"报错","slug":"报错","permalink":"https://kuai-hua.github.io/categories/%E6%8A%A5%E9%94%99/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://kuai-hua.github.io/categories/Mybatis/"},{"name":"VMware","slug":"VMware","permalink":"https://kuai-hua.github.io/categories/VMware/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"https://kuai-hua.github.io/categories/SpringMvc/"},{"name":"springcloud","slug":"springcloud","permalink":"https://kuai-hua.github.io/categories/springcloud/"},{"name":"Spring","slug":"Spring","permalink":"https://kuai-hua.github.io/categories/Spring/"},{"name":"Mysql","slug":"Mysql","permalink":"https://kuai-hua.github.io/categories/Mysql/"},{"name":"git","slug":"git","permalink":"https://kuai-hua.github.io/categories/git/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kuai-hua.github.io/categories/SpringCloud/"},{"name":"springboot","slug":"springboot","permalink":"https://kuai-hua.github.io/categories/springboot/"},{"name":"Ajax","slug":"Ajax","permalink":"https://kuai-hua.github.io/categories/Ajax/"},{"name":"Linux","slug":"Linux","permalink":"https://kuai-hua.github.io/categories/Linux/"},{"name":"hexo","slug":"hexo","permalink":"https://kuai-hua.github.io/categories/hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"https://kuai-hua.github.io/tags/git/"},{"name":"Swagger","slug":"Swagger","permalink":"https://kuai-hua.github.io/tags/Swagger/"},{"name":"mysql","slug":"mysql","permalink":"https://kuai-hua.github.io/tags/mysql/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://kuai-hua.github.io/tags/zookeeper/"},{"name":"dubbo","slug":"dubbo","permalink":"https://kuai-hua.github.io/tags/dubbo/"}]}